## 개요
정렬은 실행하는 방법에 따라 두 가지로 나눌 수 있다.
**비교식 정렬**은 한 번에 두 개씩 비교하여 교환하여 정렬하는 방식이고,
**분배식 정렬**은 키값을 기준으로 자료를 여러 개의 부분집합으로 분해하고 부분집합을 정렬함으로써 전체를 정렬하는 방식이다.

오늘은 비교식 정렬 중 병합 정렬, 힙 정렬에 대하여 다루겠습니다!

## 병합 정렬

### 병합 정렬이란?
- 병합 정렬(Merge Sort)은 여러 개의 정렬된 집합을 병합하여 하나의 정렬된 집합으로 만드는 정렬 방법이다.
- 자료를 부분집합으로 분할 하고 부분집합에 대해 작업을 정복 하고 부분집합들을 다시 결합 하는 분할과 정복(Divide and Conquer) 방법을 사용한다.
- 병합 정렬은 순차적인 비교를 통해 정렬하므로, LinkedList의 정렬에 효율적이다.
- 동일한 값에 대해 기존의 순서가 유지되는 안정 정렬이다.

💡 여기서 잠깐!!!

1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.

2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.

3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.




[![mergesort.gif](https://i.postimg.cc/Gtc2HDs1/mergesort.gif)](https://postimg.cc/S2vqPJrZ)

### 복잡도
- 공간 복잡도 : 원래의 자료 n개에 대해 정렬할 원소를 저장할 2*n개 의 추가공간 필요
- 시간 복잡도
    - 분할 : n개 원소를 두 개로 분할 -> O(log2n)
    - 병합 : 최대 n번의 비교 연산 -> O(n)
    - 따라서 시간 복잡도는 O(nlog2n)이다.



[![image.png](https://i.postimg.cc/ZKrqr4Sq/image.png)](https://postimg.cc/jLSKTVCV)
[![1.png](https://i.postimg.cc/DzmJQH6Y/1.png)](https://postimg.cc/Ff5HNP2j)
[![2.png](https://i.postimg.cc/SK5XgdtQ/2.png)](https://postimg.cc/mcY2DYsK)

여기서 주의할 점은 병합정렬의 구현이 반드시 2개의 부분리스트로 나누어야 한다는 점은 아니다.

어디까지나 가장 일반적으로 구현되는 방식이 절반으로 나누는 방식일 뿐이다. 보통 위와 같이 두 개의 부분리스트로 나누는 방식을 two-way 방식이라고 하니 참고하시면 좋을 듯 하다.
일단 우리가 이해하고 있어야 할 점은 각각의 부분리스트는 '정렬된 상태'라는 점이다.
두 부분리스트를 합쳐서 정렬할 때 굳이 삽입, 버블 정렬 등을 활용할 필요가 없다는 것이다. 그럼 어떻게 정렬을해? 라고 묻는다면 각 부분리스트의 첫 번째 원소부터 순차적으로 비교만 해주면 된다.

```
public class Main {
    public static int[] src;
    public static int[] tmp;
    public static void main(String[] args) {
        src = new int[]{1,9,8,5,4,2,3,7,6};
        tmp = new int[src.length];
        printArray(src);
        mergeSort(0, src.length - 1);
        printArray(src);
    }
    public static void mergeSort(int start, int end) {
        if (start < end) {
            int mid = (start + end) / 2;
            mergeSort(start, mid);
            mergeSort(mid + 1, end);
            int p = start;
            int q = mid + 1;
            int idx = p;
            while (p <= mid || q <= end) {
                if (q > end || (p <= mid && src[p] < src[q])) {
                    tmp[idx ++] = src[p ++];
                } else {
                    tmp[idx ++] = src[q ++];
                }
            }
            for (int i = start; i <= end; i ++) {
                src[i] = tmp[i];
            }
        }
    }
    public static void printArray(int[] a) {
        for (int i = 0; i < a.length; i ++) 
            System.out.print(a[i] + " ");
        
        System.out.println();
    }
}
```
[![4.png](https://i.postimg.cc/kXrp0dtK/4.png)](https://postimg.cc/dDB6Cp6V)


## 힙 정렬

### 힙 정렬이란?
- 힙 정렬(Heap Sort)은 Heap 자료구조를 이용해 정렬하는 방법이다.
- 최대 히프 에서 원소 개수만큼 삭제 연산을 수행하면 내림차순으로 정렬된 원소를 얻을 수 있고, 최소 히프 에서 원소 개수만큼 삭제 연산을 수행하면 오름차순으로 정렬된 원소를 얻을 수 있다는 성질을 이용한다.
- 동일한 값에 대해 기존의 순서가 유지되지 않는 불안정 정렬이다.

[![heapsort.gif](https://i.postimg.cc/sDG8Mg5M/heapsort.gif)](https://postimg.cc/QHsSPs4D)

(1) 정렬할 원소에 대해 삽입 연산을 통해 최대 히프 구성
(2) 최대 히프 에서 삭제 연산하여 배열의 비어있는 자리 중 마지막 자리에 저장
(3) 남은 히프를 최대 히프 로 재구성
(4) 공백 히프가 될 때 까지 (2) ~ (3) 반복

### 복잡도
- 공간 복잡도 : 원래의 자료 n개에 대해 n개의 메모리 와 n개의 원소를 담을 수 있는 히프 추가 필요
- 시간 복잡도
    - 정렬된 원소 구하기(히프 재구성) : 완전 이진 트리를 히프로 구성하는 평균 시간 O(log2n)
    - n개 노드에 대해 삭제 연산한 히프 재구성 시간 : O(nlog2n)
    - 따라서 시간 복잡도는 O(nlog2n)이다.



- 힙은 '최솟값 또는 최댓값을 빠르게 찾아내기 위해 완전이진트리 형태로 만들어진 자료구조'다.

- 위 문장에서 중요한 키워드 3가지가 있다. 바로 '최솟값 또는 최댓값' , '빠르게', '완전이진트리' 이다

- '부모 노드는 항상 자식 노드보다 우선순위가 높다.'

 - 즉, 모든 요소들을 고려하여 우선순위를 정할 필요 없이 부모 노드는 자식노드보다 항상 우선순위가 앞선다는 조건만 만족시키며 완전이진트리 형태로 채워나가는 것이다.



[![5.png](https://i.postimg.cc/XNmzR1JM/5.png)](https://postimg.cc/w352JVLF)
이를 조금만 돌려서 생각해보면 루트 노드(root node)는 항상 우선순위가 높은 노드라는 것이다. 이러한 원리로 최댓값 혹은 최솟값을 빠르게 찾아낼 수 있다는 장점(시간복잡도 : O(1))과 함께 삽입 삭제 연산시에도 부모노드가 자식노드보다 우선순위만 높으면 되므로 결국 트리의 깊이만큼만 비교를 하면 되기 때문에 O(logN) 의 시간복잡도를 갖아 매우 빠르게 수행할 수 있다.

그리고 위 이미지에서도 볼 수 있지만 부모노드와 자식노드간의 관계만 신경쓰면 되기 때문에 형제 간 우선순위는 고려되지 않는다.
이러한 정렬 상태를 흔히 '반 정렬 상태' 혹은 '느슨한 정렬 상태' , '약한 힙(weak heap)'이라고도 불린다.

그럼 이런 질문이 나올 수 있다. "왜 형제간의 대소비교가 필요 없다는 거죠?"

우선순위가 높은 순서대로 뽑는 것이 포인트다. 즉, 원소를 넣을 때도 우선순위가 높은 순서대로 나올 수 있도록 유지가 되야하고 뽑을 때 또한 우선순위가 높은 순서 차례대로 나오기만 하면 된다.



힙 자료구조는 크게 두 가지로 나뉘는데, 최대 힙과 최소 힙이다. (바로 위 이미지에서는 최소 힙에 해당한다.)

 

힙은 우선순위가 높은 순서대로 나온다고 했다. 이 말은 여러분이 어떻게 우선순위를 매기냐에 따라 달라지겠지만, 기본적으로 정수, 문자, 문자열 같은 경우 언어에서 지원하는 기본 정렬 기준들이 있다.

 

예로들어 정수나 문자의 경우 낮은 값이 높은 값보다 우선한다.

우리가 예로 {3, 1, 6, 4} 를 정렬한다고 하면 낮은 순서대로 {1, 3, 4, 6} 이렇게 정렬하게 된다. 이렇게 정렬되는 순서, 즉 기본적으로 어떤 것을 우선순위가 높다고 할지에 따라 두 가지로 나뉜다.


[![7.png](https://i.postimg.cc/J0Z5Vq6m/7.png)](https://postimg.cc/fSW9YxQg)


최소 힙 : 부모 노드의 값(key 값) ≤ 자식 노드의 값(key 값)

최대 힙 : 부모 노드의 값(key 값) ≥ 자식 노드의 값(key 값)

 

이렇게 두 가지로 나뉜다.
```
/*
* 힙 정렬 (Heap sort)
* 정렬하고자 하는 배열을 힙 자료구조로 만들고, 이의 특성을 이용한 정렬
*/

private void solve() {
    int[] array = { 7, 3, 4, 2, 1, 5, 6 };     
    heapSort(array);     
    for (int v : array) {        
        System.out.println(v);    
    }
} 

public static void heapify(int array[], int n, int i) {    
    int p = i;    
    
    // 자식 왼쪽 노드
    int l = i * 2 + 1;
    // 자식 오른쪽 노드
    int r = i * 2 + 2;
    
    // 부모, 자식 중 가장 작은 값 탐색
    if (l < n && array[p] > array[l]) {     
        p = l;   
    }     
    
    if (r < n && array[p] > array[r]) {        
        p = r;    
    }      
    
    // 부모 자식 관계 바뀌어야 한다면
    if (i != p) {
        // 부모 자식 위치 변경
        swap(array, p, i);
        // 위치 변경 이후에도 그 자식과 변경될 여지 있는지 재귀로 확인
        heapify(array, n, p);
    }
} 

public static void heapSort(int[] array) {    
    int n = array.length;  
    
    // 최소 힙 생성
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(array, n, i);
    }     
    
    // 최소 힙에서 추출, 나머지 배열 다시 힙으로 재구성
    for (int i = n - 1; i > 0; i--) { 
        swap(array, 0, i);     
        heapify(array, i, 0);    
    }
} 

public static void swap(int[] array, int a, int b) {    
    int temp = array[a];   
    array[a] = array[b];    
    array[b] = temp;
}
```

## 백준 문제
### [백준 2751번 수 정렬하기2](https://www.acmicpc.net/problem/2751)
```
import sys

N = int(input())
ans_list = []

for i in range(N):
    ans_list.append(int(sys.stdin.readline()))

def mergeSort(checkArr):
    if len(checkArr) < 2:
        return checkArr

    # 재귀를 통한 분할 과정
    mid = len(checkArr) // 2
    front_arr = mergeSort(checkArr[:mid])
    back_arr = mergeSort(checkArr[mid:])

    # 분할이 끝나면 front와 back으로 분할 된 배열의 0번째 수부터 비교하여 다시 병합
    mergedArr = []
    l = h = 0
    while l < len(front_arr) and h < len(back_arr):
        if front_arr[l] < back_arr[h]:
            mergedArr.append((front_arr[l]))
            l += 1
        else:
            mergedArr.append(back_arr[h])
            h += 1
    # 두 배열 중 하나의 배열이 모두 담긴 상황이라면 다른 배열의 나머지 값들도 넣어주기 (이미 정렬됨)
    mergedArr += front_arr[l:]
    mergedArr += back_arr[h:]
    return mergedArr

for j in mergeSort(ans_list):
    print(j)
```

### [백준 알고리즘 수업 - 힙 정렬 1](https://www.acmicpc.net/problem/24173)
### [힙 정렬](https://www.acmicpc.net/problem/2220)
