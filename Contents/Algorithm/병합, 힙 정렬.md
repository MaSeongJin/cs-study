## 개요
정렬은 실행하는 방법에 따라 두 가지로 나눌 수 있다.
**비교식 정렬**은 한 번에 두 개씩 비교하여 교환하여 정렬하는 방식이고,
**분배식 정렬**은 키값을 기준으로 자료를 여러 개의 부분집합으로 분해하고 부분집합을 정렬함으로써 전체를 정렬하는 방식이다.

오늘은 비교식 정렬 중 병합 정렬, 힙 정렬에 대하여 다루겠습니다!

## 병합 정렬

### 병합 정렬이란?
- 병합 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할한 뒤에 각자 계산하고 나중에 합치는 방법을 채택합니다.
- 즉 기본 아이디어는 일단 정확히 반으로 나누고 나중에 정렬하는 것입니다.
- 자료를 부분집합으로 분할 하고 부분집합에 대해 작업을 정복 하고 부분집합들을 다시 결합 하는 분할과 정복(Divide and Conquer) 방법을 사용한다.
- 병합 정렬은 순차적인 비교를 통해 정렬하므로, LinkedList의 정렬에 효율적이다.
- 동일한 값에 대해 기존의 순서가 유지되는 **안정 정렬**이다.

💡 여기서 잠깐!!!

1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.

2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.

3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.




[![mergesort.gif](https://i.postimg.cc/Gtc2HDs1/mergesort.gif)](https://postimg.cc/S2vqPJrZ)

### 복잡도
- 공간 복잡도 : 원래의 자료 n개에 대해 정렬할 원소를 저장할 2*n개 의 추가공간 필요
- 시간 복잡도
    - 분할 : n개 원소를 항상 두 개로 분할 -> O(logN)
    - 병합 : 최대 n번의 비교 연산 -> O(N) <br>
      ※정렬에 N만 걸리는 이유는 삽입 정렬과 동일한 이유입니다. 바로 '부분 집합은 이미 정렬이 되어 있는 상태'라고 가정하기 때문입니다. 이미 정렬이 되어있는 것 두 개 합치는 것은 시간 복잡도 O(N)이면 충분하기 때문입니다.
    - 따라서 시간 복잡도는 O(NlogN)이다.



[![image.png](https://i.postimg.cc/ZKrqr4Sq/image.png)](https://postimg.cc/jLSKTVCV)
[![1.png](https://i.postimg.cc/DzmJQH6Y/1.png)](https://postimg.cc/Ff5HNP2j)
[![2.png](https://i.postimg.cc/SK5XgdtQ/2.png)](https://postimg.cc/mcY2DYsK)

여기서 주의할 점은 합병정렬의 구현이 반드시 2개의 부분리스트로 나누어야 한다는 점은 아니다.

어디까지나 가장 일반적으로 구현되는 방식이 절반으로 나누는 방식일 뿐이다. 보통 위와 같이 두 개의 부분리스트로 나누는 방식을 two-way 방식이라고 하니 참고하시면 좋을 듯 하다.
일단 우리가 이해하고 있어야 할 점은 각각의 부분리스트는 '정렬된 상태'라는 점이다.
두 부분리스트를 합쳐서 정렬할 때 굳이 삽입, 버블 정렬 등을 활용할 필요가 없다는 것이다. 그럼 어떻게 정렬을해? 라고 묻는다면 각 부분리스트의 첫 번째 원소부터 순차적으로 비교만 해주면 된다.

```
public class Main {
    public static int[] src;
    public static int[] tmp;
    public static void main(String[] args) {
        src = new int[]{1,9,8,5,4,2,3,7,6};
        tmp = new int[src.length];
        printArray(src);
        mergeSort(0, src.length - 1);
        printArray(src);
    }
    public static void mergeSort(int start, int end) {
        if (start < end) {
            int mid = (start + end) / 2;
            mergeSort(start, mid);
            mergeSort(mid + 1, end);
            int p = start;
            int q = mid + 1;
            int idx = p;
            while (p <= mid || q <= end) {
                if (q > end || (p <= mid && src[p] < src[q])) {
                    tmp[idx ++] = src[p ++];
                } else {
                    tmp[idx ++] = src[q ++];
                }
            }
            for (int i = start; i <= end; i ++) {
                src[i] = tmp[i];
            }
        }
    }
    public static void printArray(int[] a) {
        for (int i = 0; i < a.length; i ++) 
            System.out.print(a[i] + " ");
        
        System.out.println();
    }
}
```
[![4.png](https://i.postimg.cc/kXrp0dtK/4.png)](https://postimg.cc/dDB6Cp6V)


## 힙 정렬

### 힙 정렬이란?
- 힙 정렬(Heap Sort)은 Heap 자료구조를 이용해 정렬하는 방법이다.
- 힙 정렬(Heap Sort)은 병합 정렬(Merge Sort)와 퀵 정렬(Quick Sort)만큼 빠른 정렬 알고리즘입니다.
- 최대 히프 에서 원소 개수만큼 삭제 연산을 수행하면 내림차순으로 정렬된 원소를 얻을 수 있고, 최소 히프 에서 원소 개수만큼 삭제 연산을 수행하면 오름차순으로 정렬된 원소를 얻을 수 있다는 성질을 이용한다.
- 동일한 값에 대해 기존의 순서가 유지되지 않는 **불안정 정렬**이다.
- 힙은 '최솟값 또는 최댓값을 빠르게 찾아내기 위해 완전이진트리 형태로 만들어진 자료구조'다.
- 위 문장에서 중요한 키워드 3가지가 있다. 바로 '최솟값 또는 최댓값' , '빠르게', '완전이진트리' 이다
- 부모 노드는 항상 자식 노드보다 우선순위가 높다.
- 즉, 모든 요소들을 고려하여 우선순위를 정할 필요 없이 부모 노드는 자식노드보다 항상 우선순위가 앞선다는 조건만 만족시키며 완전이진트리 형태로 채워나가는 것이다.

### 이진 트리(Binary Tree) 기억 점검!
 - 힙을 알기 전에는 이진 트리(Binary Tree)에 대해서 알고 있을 필요가 있습니다. 이진 트리란 컴퓨터 안에서 데이터를 표현할 때 데이터를 각 노드(Node)에 담은 뒤에 노드를 두 개씩 이어 붙이는 구조를 말합니다. 이 때 트리 구조에 맞게 부모 노드에서 자식 노드로 가지가 뻗힙니다. 이진 트리는 모든 노드의 자식 노드가 2개 이하인 노드입니다. 
 - 완전 이진 트리는 데이터가 루트(Root) 노드부터 시작해서 자식 노드가 왼쪽 자식 노드, 오른쪽 자식 노드로 차근차근 들어가는 구조의 이진 트리입니다. 즉 완전 이진 트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽히 가득 찬 구조입니다.(항상 왼쪽 자식 노드부터 데이터가 들어감)

[![heapsort.gif](https://i.postimg.cc/sDG8Mg5M/heapsort.gif)](https://postimg.cc/QHsSPs4D)<br>

(1) 정렬할 원소에 대해 삽입 연산을 통해 최대 히프 구성 <br>
(2) 최대 히프 에서 삭제 연산하여 배열의 비어있는 자리 중 마지막 자리에 저장 <br>
(3) 남은 히프를 최대 히프 로 재구성 <br>
(4) 공백 히프가 될 때 까지 (2) ~ (3) 반복 <br>

[![1.png](https://i.postimg.cc/G2FXzp7x/1.png)](https://postimg.cc/tZgd49Hs)<br>
- 힙 정렬을 수행하기 위해서는 힙 생성 알고리즘(Heapify Algorithm)을 사용합니다. 힙 생성 알고리즘은 특정한 '하나의 노드'에 대해서 수행하는 것입니다. 또한 해당 '하나의 노드를 제외하고는 최대 힙이 구성되어 있는 상태'라고 가정을 한다는 특징이 있습니다. 위의 그림이 정확히 해당 가정에 부합합니다. 위 트리에서 5만 최대 힙 정렬을 수행해주면 전체 트리가 최대 힙 구조로 형성되는 상태입니다. 힙 생성 알고리즘(Heapify Algorithm)은 특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 바꾸는 알고리즘입니다. 또한 위치를 바꾼 뒤에도 여전히 자식이 존재하는 경우 또 자식 중에서 더 큰 자식과 자신의 위치를 바꾸어야 합니다. 자식이 더이상 존재하지 않을 때 까지요. 즉 위 예시에서는 5의 두 자식인 7과 4 중에서 더 큰 자식인 7과 5의 위치를 바꾸어주면 됩니다. 바꾼 결과는 아래와 같습니다.

[![2.png](https://i.postimg.cc/FzhD6Qw5/2.png)](https://postimg.cc/8JnRFx1t)<br>
- 위와 같이 힙 생성 알고리즘은 전체 트리를 힙 구조를 가지도록 만든다는 점에서 굉장히 중요한 알고리즘입니다. 이러한 힙 생성 알고리즘의 시간 복잡도는 몇 일까요? 한 번 자식 노드로 내려갈 때마다 노드의 갯수가 2배씩 증가한다는 점에서 **O(log N)**입니다. 예를 들어 데이터의 갯수가 1024(2^10)개라면 대략 10번 정도만 내려가도 된다는 거에요. 

### 복잡도
- 공간 복잡도 : 원래의 자료 n개에 대해 n개의 메모리 와 n개의 원소를 담을 수 있는 히프 추가 필요
- 시간 복잡도 : O(nlog2n)이다.


### 문제 적용 실습
[![3.png](https://i.postimg.cc/nzSG3QK7/3.png)](https://postimg.cc/DJsGZ0My)<br>
- 완전 이진 트리에 삽입이 되는 순서대로 인덱스를 붙여주는 겁니다. 위 배열을 완전 이진 트리 형태로 출력하면 다음과 같습니다.<br>
[![4.png](https://i.postimg.cc/Zn9F2KjQ/4.png)](https://postimg.cc/BP0K13r5)<br>
배열에 있는 인덱스가 그대로 차례대로 트리로 표현된 것입니다. 위와 같은 상황에서 모든 원소를 기준으로 힙 생성 알고리즘을 적용해서 전체 트리를 힙 구조로 만들어주시면 됩니다. 이 때 데이터의 갯수가 N개 이므로 전체 트리를 힙 구조로 만드는 복잡도는 O(N * log N)입니다. ( 사실상  모든 데이터를 기준으로 힙 생성 알고리즘을 쓰지 않아도 되기 때문에 O(N)에 가까운 속도를 낼 수 있습니다. )<br>

[![5.png](https://i.postimg.cc/C5WHgTQx/5.png)](https://postimg.cc/PvQ8WcHg)<br>
그래서 결과적으로는 위와 같이 최대 힙이 구성됩니다. 고작 O(N * logN)으로 위와 같이 만들 수 있는 겁니다. 이제부터 실제로 우리가 원하던 정렬을 직관적으로 수행할 수 있습니다. 루트(Root)에 있는 값을 가장 뒤쪽으로 보내면서 힙 트리의 크기를 1씩 빼주는 겁니다.<br>

[![6.png](https://i.postimg.cc/TYr1J5X4/6.png)](https://postimg.cc/YhCtp906)<br>
 즉 위와 같이 9와 6을 바꾼 뒤에 9는 정렬이 완료된 것이므로 빨간색으로 처리합니다. 이제 9를 제외하고 나머지 8개 원소를 기준으로 또 힙 생성 알고리즘(Heapify)를 수행합니다. 결과는 다음과 같습니다.<br>
[![7.png](https://i.postimg.cc/W1T3WpNb/7.png)](https://postimg.cc/LnQ2hpgr)<br>
이제 다시 가장 큰 숫자인 8이 루트에 존재합니다. 이것을 가장 뒤 쪽의 원소와 서로 바꿉니다.<br>
[![9.png](https://i.postimg.cc/SxdKw0RL/9.png)](https://postimg.cc/pm9xF6Dy)<br>
 그럼 위와 같이 8과 9가 가장 뒤에 배열되어 정렬이 이루어졌습니다. 이제 이 과정을 반복하시면 됩니다. 힙 생성 알고리즘의 시간 복잡도는 O(log N)이고 전체 데이터의 갯수가 N개이므로 시간 복잡도는 **O(N * log N)**이라고 할 수 있습니다. 또한 아까전에 계산했던 맨 처음에 힙 구조를 만드는 복잡도는 O(N * log N)이었습니다. 한 마디로 전체 힙 정렬의 전체 시간 복잡도는  O(N * log N)입니다.

<br><br>




### 다시 정리해보자!
[![5.png](https://i.postimg.cc/XNmzR1JM/5.png)](https://postimg.cc/w352JVLF)<br>
루트 노드(root node)는 항상 우선순위가 높은 노드라는 것이다. 이러한 원리로 최댓값 혹은 최솟값을 빠르게 찾아낼 수 있다는 장점(시간복잡도 : O(1))과 함께 삽입 삭제 연산시에도 부모노드가 자식노드보다 우선순위만 높으면 되므로 결국 트리의 깊이만큼만 비교를 하면 되기 때문에 O(logN) 의 시간복잡도를 갖아 매우 빠르게 수행할 수 있다.

그리고 위 이미지에서도 볼 수 있지만 부모노드와 자식노드간의 관계만 신경쓰면 되기 때문에 형제 간 우선순위는 고려되지 않는다.
이러한 정렬 상태를 흔히 '반 정렬 상태' 혹은 '느슨한 정렬 상태' , '약한 힙(weak heap)'이라고도 불린다.

그럼 이런 질문이 나올 수 있다. "왜 형제간의 대소비교가 필요 없다는 거죠?"

우선순위가 높은 순서대로 뽑는 것이 포인트다. 즉, 원소를 넣을 때도 우선순위가 높은 순서대로 나올 수 있도록 유지가 되야하고 뽑을 때 또한 우선순위가 높은 순서 차례대로 나오기만 하면 된다.



힙 자료구조는 크게 두 가지로 나뉘는데, 최대 힙과 최소 힙이다. (바로 위 이미지에서는 최소 힙에 해당한다.)

 

힙은 우선순위가 높은 순서대로 나온다고 했다. 이 말은 여러분이 어떻게 우선순위를 매기냐에 따라 달라지겠지만, 기본적으로 정수, 문자, 문자열 같은 경우 언어에서 지원하는 기본 정렬 기준들이 있다.

 

예로들어 정수나 문자의 경우 낮은 값이 높은 값보다 우선한다.

우리가 예로 {3, 1, 6, 4} 를 정렬한다고 하면 낮은 순서대로 {1, 3, 4, 6} 이렇게 정렬하게 된다. 이렇게 정렬되는 순서, 즉 기본적으로 어떤 것을 우선순위가 높다고 할지에 따라 두 가지로 나뉜다.


[![7.png](https://i.postimg.cc/J0Z5Vq6m/7.png)](https://postimg.cc/fSW9YxQg)


**최소 힙 : 부모 노드의 값(key 값) ≤ 자식 노드의 값(key 값)**

**최대 힙 : 부모 노드의 값(key 값) ≥ 자식 노드의 값(key 값)**

 

```
/*
* 힙 정렬 (Heap sort)
* 정렬하고자 하는 배열을 힙 자료구조로 만들고, 이의 특성을 이용한 정렬
*/

#include <stdio.h>

int number = 9;
int heap[9] = {7, 6, 5, 8, 3, 5, 9, 1, 6};

int main(void) {
	// 힙을 구성 
	for(int i = 1; i < number; i++) {
		int c = i;
		do {
			int root = (c - 1) / 2;
			if(heap[root] < heap[c]) {
				int temp = heap[root];
				heap[root] = heap[c];
				heap[c] = temp;
			}
			c = root;
		} while (c != 0);
	}
	// 크기를 줄여가며 반복적으로 힙을 구성
	for (int i = number - 1; i >= 0; i--) { 
		int temp = heap[0];
		heap[0] = heap[i];
		heap[i] = temp;
		int root = 0;
		int c = 1;
		do {
			c = 2 * root + 1;
			// 자식 중에 더 큰 값을 찾기 
			if(c < i - 1 && heap[c] < heap[c + 1]) {
				c++;
			}
			// 루트보다 자식이 크다면 교환 
			if(c < i && heap[root] < heap[c]) {
				temp = heap[root];
				heap[root] = heap[c];
				heap[c] = temp;
			}
			root = c;
		} while (c < i);
	} 
	// 결과 출력 
	for(int i = 0; i < number; i++) {
		printf("%d ", heap[i]);
	}
}
```

### 힙 정렬을 마치며
힙 정렬은 병합 정렬과 다르게 별도로 추가적인 배열이 필요하지 않다는 점에서 메모리 측면에서 몹시 효율적입니다. 또한 항상 O(N * log N)을 보장할 수 있다는 점에서 몹시 강력한 정렬 알고리즘입니다. 이론적으로는 퀵 정렬, 병합 정렬보다 더 우위에 있다고 할 수 있습니다. 하지만 단순히 속도만 가지고 비교하면 퀵 정렬이 평균적으로 더 빠르기 때문에 힙 정렬이 일반적으로 많이 사용되지는 않습니다.

## 풀어보면 좋은 백준 문제
### [백준 2751번 수 정렬하기2](https://www.acmicpc.net/problem/2751)
### [백준 알고리즘 수업 - 힙 정렬 1](https://www.acmicpc.net/problem/24173)
### [힙 정렬](https://www.acmicpc.net/problem/2220)
