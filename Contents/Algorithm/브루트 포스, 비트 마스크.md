# 브루트 포스 알고리즘

---

## 브루트포스 알고리즘이란?

**Brute(단순히, 순전히) Force(힘)** 

⇒ 순전히 힘만 갖고 밀어붙인다…

머리를 쓰지 않고 모든 것을 다 해보겠다는 뜻

**완전 탐색 알고리즘**으로, 가능한 모든 경우의 수를 탐색해보는 알고리즘이다.

ex) 4자리 수 비밀번호를 알아내기 위해 0000~9999까지 입력해보는 것

```java
for(int i = 0; i <10000 ; i++){
	 try(i);
}
```

암호 한번 입력하는데 5초가 걸리면 14시간이 걸림

⇒ but 컴퓨터는 **1초에 약 1억번**의 연산이 가능.. <br><br>

✅ 알고리즘 문제를 풀 때 브루트 포스로 풀 수 있는지 확인하는 방법?

⇒ 제한 시간 1초면 연산이 1억번 넘어가면 안됨..

⇒10000개 입력 받아서 이중 for문 돌리면 대충 1억…

---
### 브루트포스의 구현
1. for문 / while문을 이용한 탐색
2. 백트래킹(재귀)을 이용한 탐색
3. DFS & BFS 탐색 ..
---
**브루트 포스 관련 문제들**

[2798번: 블랙잭 (acmicpc.net)](https://www.acmicpc.net/problem/2798) (백준 2798 블랙잭)

[2309번: 일곱 난쟁이 (acmicpc.net)](https://www.acmicpc.net/problem/2309) (백준 2309 일곱 난쟁이)

---
# 비트마스크

---

## 비트(bit)

비트(binary digit)는 **데이터를 나타내는 최소 단위**로 이진수의 한자리인 0 또는 1의 값을 가진다. 

부호 없는 N비트 정수형 변수는 N자리의 이진수로 나타낼 수 있다. 이때 비트가 표현하는 값은 2^0 ~ 2^N-1까지이다.

여기서 2^N-1에 해당하는 비트값을 **최상위 비트**(Most Significant Bit)라 하고, 2^0에 해당하는 비트값을 **최하위 비트**(Least Significant Bit)라고 한다.

예를 들어 부호없는 4비트 정수형은 네 자리 이진수로 표시할 수 있는 모든 정수를 나타낼 수 있다. 아래 그림과 같이 4칸의 공간에 이진수 0 또는 1을 넣은 모든 경우의 수를 의미한다. 이때 비트가 표현하는 값은 2^0~2^3이다.

[![image.png](https://i.postimg.cc/2SysqYPm/image.png)](https://postimg.cc/gx9S5CzB)<br>
여기서는 2^3이 최상위 비트이고 2^0에 해당하는 비트값(1)이 최하위이다.

---
## 비트 연산자

[![image.png](https://i.postimg.cc/FKcncHGt/image.png)](https://postimg.cc/zLzjY59p)

[![image.png](https://i.postimg.cc/gcfsyWXm/image.png)](https://postimg.cc/RqLw92LD)

[![image.png](https://i.postimg.cc/pV8zHnrM/image.png)](https://postimg.cc/XXjpKq9s)
---
### 비트 연산자 사용 시 주의사항

1. 비교 연산자 ( >, < , ==, …) 보다 우선 순위가 낮기 때문에 생각한 답이 나오지 않을 수 있다! ⇒ 비교 연산자와 같이 쓸 때는 괄호를 씌우는 게 좋다.
2. 오버플로우가 발생할 수 있다.
64비트 정수를 비트마스크로 사용할 때 오버플로우가 발생한다. 이럴 때는 1뒤에 64비트 정수임을 나타내는 **ull(unsigned long long)**을 붙여서 사용하면 된다.
---
## 비트마스크(Bit Mask)란?

이진수를 사용하는 컴퓨터의 연산 방식을 이용하여 정수의 이진수 표현을 자료 구조로 사용하는 기법을 말한다.<br>
✅ 이진수 0 또는 1을 이용하므로 하나의 비트가 표현할 수 있는 경우는 두 가지이다.

---
### 비트마스크 장점

1. 다른 자료 구조에 비해 수행 시간이 더 빠르다.<br>
→ 비트마스크 연산은 bit 연산이기 때문에 **O(1)**에 구현되는 것이 많다.<br>
2. 비트 연산자를 사용하여 코드가 더 간결해진다.<br>
3. 적은 메모리 사용량<br>
→ 하나의 정수로 많은 경우의 수를 표현 가능<br>
---
### 비트마스크를 이용한 집합 구현

비트마스크를 이용한 집합 구현은 가장 대표적이고, 자주 쓰이는 방법이다. 하나의 bit가 하나의 데이터 상태를 의미한다. 
bit가 **1이면 해당 원소가 집합에 포함되어 있다는 의미**이고, **0이면 포함되어 있지 않다는 의미**이다. 
따라서, N비트는 N개의 원소를 갖는 집합의 부분집합들을 모두 표현할 수 있다.

[![image.png](https://i.postimg.cc/KvT1LXBX/image.png)](https://postimg.cc/4mJ4kSWw)

**공집합과 꽉 찬 집합 구하기**

☛ 기본적으로 공집합은 bit가 모두 꺼진 상황이기 때문에 상수 0이 공집합을 표현한다. 반대로 꽉 찬 집합은 bit가 모두 켜진 상황이기 때문에 원소가 K-1개인 꽉 찬 집합을 구하려면 2^K에서 1을 뺀 값으로 표현한다.

ex.  10000 - 1  ⇒  01111  (4개의 원소를 가진 꽉 찬 집합)
<br> <br>

**원소 추가**

☛ A 집합에 특정 원소를 추가하는 방법이다. 원소에 해당하는 bit만 켜야 하기 때문에 해당 bit를 항상 1로 만드는 연산이 필요하기 때문에 따라서 OR 연산을 이용한다.
<br> <br>

**원소 삭제**

☛ A 집합에 포함된 특정 원소를 삭제하는 방법이다. A에 k번째 원소의 포함 여부와 상관없이 해당 bit를 끄기 위해서는 AND 연산을 이용해야 한다.

1<<k : k번째가 켜진 상태

^(1<<k) : k번째만 꺼진 상태

A &= ^(1<<k); : A 집합에 담긴 k번째 상태 off <br>

 <br> <br>
※주의※<br>
A -= (1<<k); :이는 A에 반드시 k번째 원소가 포함되어 있는 경우에만 가능하다. 만약 포함되어 있지 않은 상태에서 삭제 연산을 하게 되면 데이터가 망가진다.
<br> <br>

**원소의 포함 여부 확인**

☛ A 집합에 특정 원소가 포함되어 있는지 확인하는 방법이다. k번째 원소가 포함되어 있는지 확인하고 싶다면, k번째 bit가 켜져 있는지만 확인하면 된다.
<br> <br>

**원소의 토글**

☛ A 집합에 해당 원소가 빠져있는 경우에는 추가하고, 들어있는 경우에는 삭제하는 방법이다. XOR 연산을 이용한다.
<br> <br>

**두 집합에 대해 연산하기**

☛ 두 집합을 A와 B라고 한다면 비트연산자들을 통해서 A와 B의 교집합, 합집합, 차집합 등을 구할 수 있다.
<br> <br>

**최소 원소 찾기**

☛ 집합에 포함된 가장 작은 원소 (index가 가장 작은 원소)를 찾는 방법이다. 켜져 있는 bit 중에서 가장 오른쪽에 있는 bit를 찾는 것이다. 비트마스크 뿐만 아니라 펜윅 트리 (Fenwick Tree)에서도 사용되는 기법이다.

비트 A가 있다고하자.

1. 가장 오른쪽에 켜져있는 bit를 k라고 하면, 0~k-1의 bit는 모두 0이다.
2. 그렇다면 ~A에서는 k번째 bit는 0, 0~k-1의 bit는 모두 1이다.
3. ~A + 1을 하게 되면 k번째 bit는 1, 0~k-1의 bit는 모두 0이 된다. k이후의 비트는 아무 변화가 없다.
- ~A + 1 : 컴퓨터가 표현하는 A의 2의 보수 (-A)

→ 따라서, -A와 A를 AND연산을 시키면 k번째 bit만 켜진 상태로 남게 된다.

ex) int first = A & (-A);

A : 1010,

~A+1 (-A) : 0110,

A&(-A) : 0010
<br> <br>

**최소 원소 지우기**

☛ 가장 오른쪽에 켜져 있는 bit를 지우고 싶다면 A-1과 AND시키면 된다. A에서 1을 빼주게 되면 가장 오른쪽에 있던 bit는 0이 되고 그보다 오른쪽에 있는 모든 bit들이 1이 되기 때문이다.

ex) A &= (A-1);

A : 1010,

A-1 : 1001,

A&(A-1) : 1000
<br> <br>

### 비트마스크 관련 문제

[백준 2098 외판원](https://www.acmicpc.net/problem/2098) (골드1)<br>
[2309번: 일곱 난쟁이 (acmicpc.net)](https://www.acmicpc.net/problem/2309) (백준 2309 일곱 난쟁이)
```
package baekjoon.q2000;
 
import java.util.Arrays;
import java.util.Scanner;
 
public class Q2309_Bit {
    static int[] arr;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        arr = new int[9];
        for(int i=0;i<9;i++)
            arr[i] = sc.nextInt();
        // 오름차순 출력을 위해 미리 정렬해두기
        Arrays.sort(arr);
        
        for(int i=0;i<(1<<9);i++) {
            int sum = 0;
            // bit(1) 개수가 7개일 경우
            if(Integer.bitCount(i)==7) {
                for(int j=0;j<9;j++) {
                    //j만큼 1을 이동하여 i와 and 연산 결과가 1이라면(0보다 크다면)
                    if((1<<j&i)>0) sum+=arr[j];
                }
                if(sum==100) {
                    for(int j=0;j<9;j++) 
                        if((1<<j&i)>0) System.out.println(arr[j]);
                    break;
                }
            }
        }
    }
}
```


추가자료 

```
toBinaryString() 메서드 : 정수형 자료를 2진법 문자열로 바꿔주는 메소드
Integer.bitCount() 메서드 : 정수를 2진법으로 표현했을 때 1의 개수를 세는 메소드
```

보수의 이해를 돕는 내용 : https://gdnn.tistory.com/289 


