## 순열과조합 ★★   
코딩테스트를 준비하면서 또 실제로 코딩테스트를 칠때 문제속에서 자주 만나는 유형이 순열,조합이다.   
순열, 조합, 중복 순열, 중복 조합 모두가 n개에서 r개를 뽑는다는 것은 동일하다.   
순서를 신경써야하는가? 중복이가능한가? 에따라서 순열, 조합, 중복순열, 중복조합중에 문제에 적용을 하면된다.   


## 조합  
서로 다른 n개에서 순서 없이 r개를 뽑는 경우의 수  
- 순서와 상관 없다는 말은 순열과 다르게 [1,2]와 [2,1]을 같은 것으로 취급한다는 것.

### 띵균쌤코드로 구현해보기
순서가 상관이 없어 [1,2]와 [2,1]가 같다고 했기 때문에 이런 경우 [1,2]만을 카운팅 해준다.
그러기 위해서 현재 선택한 원소보다 뒤에 있는 원소에 대해서만 탐색을 진행해주기위해 재귀 호출을 할 때 idx에 1을 더한 값을 다음시작값으로 넣어주었다.

```
public class 조합_01 {
	// 재료를 준비를 했다.
	public static String[] 토핑 = { "상추", "패티", "토마토", "치즈", "새우" };
	public static int N = 5;
	public static int R = 2; // 문제에서 판단 할 수 있는 부분들
	public static String[] sel = new String[R]; // 내가 선택한 토핑

	public static void main(String[] args) {
		combination(0, 0);
	}

	// idx : 토핑의 index
	// sidx : sel의 index
	public static void combination(int idx, int sidx) {
		// 기저파트
		if (sidx == R) {
			System.out.println(Arrays.toString(sel));
			return;
		}
		if (idx == N)
			return;
		// 재귀파트
		sel[sidx] = 토핑[idx]; // 해당 재료 넣어보자.
		combination(idx + 1, sidx + 1); // idx 번째 재료 뽑은거
		combination(idx + 1, sidx); // idx 번째 재료 안뽑은거
	}
}
```

```
[상추, 패티]
[상추, 토마토]
[상추, 치즈]
[상추, 새우]
[패티, 토마토]
[패티, 치즈]
[패티, 새우]
[토마토, 치즈]
[토마토, 새우]
[치즈, 새우]
```

## 중복조합
서로 다른 n개에서 순서 없이, 중복이 가능하게 r개를 뽑는 경우의 수  
- 순서 없이 뽑는 조합과 동일하지만, 이미 뽑은 것을 또 뽑을 수 있다는, 즉 중복이 가능하다는 차이점이 있다.
  
```
public class 조합_01 {
	// 재료를 준비를 했다.
	public static String[] 토핑 = { "상추", "패티", "토마토", "치즈", "새우" };
	public static int N = 5;
	public static int R = 2; // 문제에서 판단 할 수 있는 부분들
	public static String[] sel = new String[R]; // 내가 선택한 토핑

	public static void main(String[] args) {
		combination(0, 0);
	}

	// idx : 토핑의 index
	// sidx : sel의 index
	public static void combination(int idx, int sidx) {
		// 기저파트
		if (sidx == R) {
			System.out.println(Arrays.toString(sel));
			return;
		}
		if (idx == N)
			return;
		// 재귀파트
		sel[sidx] = 토핑[idx]; // 해당 재료 넣어보자.
		combination(idx, sidx + 1); // idx 번째 재료를 다시 선택할 수 있음
		combination(idx + 1, sidx); // idx 번째 재료 안뽑은거

	}
}
```

```
[상추, 상추]
[상추, 패티]
[상추, 토마토]
[상추, 치즈]
[상추, 새우]
[패티, 패티]
[패티, 토마토]
[패티, 치즈]
[패티, 새우]
[토마토, 토마토]
[토마토, 치즈]
[토마토, 새우]
[치즈, 치즈]
[치즈, 새우]
[새우, 새우]

```

https://www.acmicpc.net/problem/16395
https://www.acmicpc.net/problem/17135
https://www.acmicpc.net/problem/17471

## 순열
서로 다른 n개에서 r개를 뽑아서 정렬하는 경우의 수  
순열의 정의에서 '정렬'이라는 단어가 순서가 있다는 순열의 특징을 나타낸다.  
- 예를 들어서 살펴보면 [1,2]와 [2,1]은 순서가 다르기 때문에, 순열에서는 다른 것으로 카운팅!  


### 띵균쌤코드로 구현해보기  
순서를 신경쓰는 순열이기 때문에, index상으로 뒤에있는 원소가 더 앞에 오는 경우도 카운팅을 해야한다. 따라서 탐색을 수행하는 반복문은 0부터 탐색을 시작해야한다.  
중복해서 선택하는 것은 불가능하기 때문에 visited를 이용해서 이미 선택한 원소를 다시 선택하지 않도록 해준다.  

```
public static String[] 토핑 = { "상추", "패티", "토마토", "치즈", "새우" };
public static int N = 5;
public static int R = 2; // 선택할 토핑의 개수
public static boolean[] visited = new boolean[N]; // 방문 여부를 저장할 배열
public static String[] sel = new String[R]; // 선택한 토핑을 저장할 배열

public static void main(String[] args) {
    permutation(0);
}

// sidx: sel의 index
public static void permutation(int sidx) {
    // 기저파트
    if (sidx == R) {
        System.out.println(Arrays.toString(sel));
        return;
    }
    
    // 재귀파트
    for (int i = 0; i < N; i++) {
        if (!visited[i]) {  
            sel[sidx] = 토핑[i];
            visited[i] = true;
            permutation(sidx + 1);
            visited[i] = false;
        }
    }
}
```
```
[상추, 패티]
[상추, 토마토]
[상추, 치즈]
[상추, 새우]
[패티, 상추]
[패티, 토마토]
[패티, 치즈]
[패티, 새우]
[토마토, 상추]
[토마토, 패티]
[토마토, 치즈]
[토마토, 새우]
[치즈, 상추]
[치즈, 패티]
[치즈, 토마토]
[치즈, 새우]
[새우, 상추]
[새우, 패티]
[새우, 토마토]
[새우, 치즈]

```

## 중복순열
서로 다른 n개에서 중복이 가능하게 r개를 뽑아서 정렬하는 경우의 수  
- 순서가 있게 뽑는 순열과 동일하지만, 같은 원소를 중복해서 뽑을 수 있다는 차이만 있다.

### 띵균쌤코드로 구현해보기
```
public static String[] 토핑 = { "상추", "패티", "토마토", "치즈", "새우" };
	public static int N = 5;
	public static int R = 2; // 선택할 토핑의 개수
	public static String[] sel = new String[R]; // 선택한 토핑을 저장할 배열

	public static void main(String[] args) {
	    Permutation(0);
	}

	// sidx: sel의 index
	public static void Permutation(int sidx) {
	    // 기저파트
	    if (sidx == R) {
	        System.out.println(Arrays.toString(sel));
	        return;
	    }
	    
	    // 재귀파트
	    for (int i = 0; i < N; i++) {
	        sel[sidx] = 토핑[i];
	        Permutation(sidx + 1);
	    }
	}
```
```
[상추, 상추]
[상추, 패티]
[상추, 토마토]
[상추, 치즈]
[상추, 새우]
[패티, 상추]
[패티, 패티]
[패티, 토마토]
[패티, 치즈]
[패티, 새우]
[토마토, 상추]
[토마토, 패티]
[토마토, 토마토]
[토마토, 치즈]
[토마토, 새우]
[치즈, 상추]
[치즈, 패티]
[치즈, 토마토]
[치즈, 치즈]
[치즈, 새우]
[새우, 상추]
[새우, 패티]
[새우, 토마토]
[새우, 치즈]
[새우, 새우]
```
## 재귀

https://www.acmicpc.net/problem/1914
https://www.acmicpc.net/workbook/view/6032
