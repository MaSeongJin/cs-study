---
# 데이터베이스의 INDEX
---
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcdsSbG%2FbtstWJDpxsY%2F4UoASKlIBxl6J3BpPLfei0%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbF33a8%2Fbtst7TjsUA4%2FnYOZPriYkD0KpR4ULzIGCk%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fv9Wwv%2Fbtst84ZrZr3%2F1Cocn3CUOMj7a8NGcIumxK%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcJCzoR%2Fbtst0zM9xPL%2FhSAWXGRksDSK98otc0hb8K%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Foi39p%2FbtstY9VADfh%2FYYFPyPi2jZlVCXPUEOMvw0%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJCU9x%2FbtstY6LmpK5%2FSGvCmklipJUJ6UAGdIRB9K%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpW8mF%2FbtstYbzm4Bf%2FDE8oRBhP5TLqKiLMDLOnD0%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPVswz%2Fbtst7R0fBLF%2F87YttwWhFNDFur03IMIDzK%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbhqrdG%2Fbtst6m7nVqk%2FjHuNtNAk2h5y4u52Yfk0O1%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fkx7Of%2FbtstY226P1h%2Ffl884kyDyCAIdSOCZZVNhK%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKYjd9%2Fbtst6Qgd6eE%2Fm6qneZUP0z4JXIne2LL14K%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPyNS7%2Fbtst5kI0Sid%2F7F9ARhcKrQqRu0hRn1czP1%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbQEyDb%2Fbtst5RzPq08%2F4uHLSRaBjZvmCGOImCHQWk%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkWYHO%2Fbtst7SERdke%2FvDvTzobonUkEcJrhQ9pkKk%2Fimg.png">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc2ry5t%2Fbtst6QN2gC2%2F2C5coMAM1vpi06M6JljWz1%2Fimg.png">

## 1. INDEX란?
- RDBMS에서 검색 속도를 높이기 위해 사용하는 하나의 기술.
- TABLE의 컬럼을 색인화(따로 파일로 저장)하여 검색시 해당 TABLE의 레코드 전체를 스캔 하는게 아니라 색인화 되어있는 INDEX 파일을 검색하여 검색속도를 빠르게 함.
- INDEX는 Tree 구조로 색인화를 사용(주로 B+Tree 사용)
- TABLE의 기본 키는 자동으로 INDEX화 됨
<br/>


## 2. INDEX의 목적
- INDEX의 목적은 해당 RDBMS의 검색 속도를 높이는 것
- INDEX는 SELECT / INSERT / UPDATE / DELETE 중 INSERT를 제외한 나머지의 성능을 향상시킴
- SELECT, UPDATE, DELETE 연산을 수행하기 위해서는 해당 대상을 조회해야만 작업할 수 있기 때문

```
// Kwon이라는 이름을 업데이트 해주기 위해서는 Kwon을 조회해야 한다.
UPDATE USER SET NAME = 'KwonJeongHun' WHERE NAME = 'Kwon';
```
<br/>

## 3. INDEX의 관리
DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 
그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 
각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.
<br/>

- INSERT: 새로운 데이터에 대한 인덱스를 추가함
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함
<br/>


## 4. INDEX의 장점
- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.
- 테이블 행의 고유성을 강화시킬 수 있다.
<br/>


## 5. INDEX의 단점
- INDEX를 관리하기 위한 추가 작업이 필요하다.
- INDEX를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- INDEX를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
- INDEX된 필드에서 데이터를 업데이트하거나 레코드를 추가 또는 삭제할 때 성능 저하를 가져온다.
<br/>


## 6. INDEX를 생성하면 좋은 경우
- 규모가 큰 테이블
- 외래키가 사용되는 컬럼
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY가 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼(반례: 성별(데이터의 중복도가 높은 컬럼))
<details>
<summary>ORDER BY에 대한 설</summary>
<div markdown="1">
ORDER BY 절의 효율성
인덱스를 사용하면 ORDER BY에 의한 정렬(Sort) 과정을 피할 수가 있다. ORDER BY는 굉장히 부하가 많이 걸리는 작업이다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 *디스크 I/O도 추가적으로 발생되기 때문이다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 된다. 왜? 이미 정렬이 되어 있기 때문에 가져오기만 하면 되기 때문이다.

*디스크 I/O : 간단하게 말해 우리가 데이터를 작성하고 변경할 적에 디스크 즉 HDD에 저장되는 것을 말한다. (디스크 I/O에 대해서는 나중에 다시 공부해볼 필요가 있을 것 같다.)

</div>
</details>


#### 인덱스를 사용한다고 해서 속도가 반드시 빨라지는 것은 아니다!
<br/>


## 7. INDEX의 자료구조: B+Tree
[ B+Tree ]
B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성을 가지고 있다.

리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
리프노드들은 LinkedList로 연결되어 있다.
데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.
데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 BTree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화하였다. (물론 Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 BTree에 비해 무조건 리프노드까지 가야한다는 단점도 있다.)

이러한 이유로 비록 B+Tree는 O(log2n
) 의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.











