## 조인의 원리

**INNER JOIN, OUTER JOIN, CROSS JOIN, SELF JOIN** 과 같은 조인의 종류들은 아래의 조인 원리들을 기반으로 이루어진다.
<br><br>

# 1. 중첩 루프 조인( Nested Loop Join )

![중첩반복](https://github.com/hajaeryul/mvc-20220927-jaeryul/assets/113097210/40acc682-a358-46bb-8ff4-14d1dca33710)
---
- 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법으로 **순차적**으로 처리된다.
- 작은 입력을 인덱스를 사용하여 조인할 때  가장 효율적 성능을 보인다.
- 정렬이나 해시 테이블 생성과 같은 대기(STOP&GO)를 해야하는 추가적인 선행 작업이 필요 없기 떄문에 추가 메모리를 사용하지 않는다. 따라서 **메모리 사용량이 가장 적다**
- 메모리를 사용하지 않는 점은 많은 동시 사용자를 처리하는 OLTP 환경에서 큰 장점으로 작용한다.
  
---

### ※주의사항※ <br>

중첩루프조인은 **Inner Table의 조인조건에 대한 인덱스 존재 유무가 매우 중요**!!

만약에 Inner Table에서 Join 컬럼이 인덱스에 걸려있지 않으면 굉장한 비효율이 발생! (이러면 Merge Join 또는 Hash Join 고려..)

why? 한건 한건 갈 때마다 전부 full scan을 해야 되므로..

따라서 Inner Table의 인덱스 구성 전략이 매우 중요하다.

건건이 JOIN을 하는 방식이기 때문에 대량의 테이블을 JOIN하는 방식으로는 부적합 ( 보통은 OLTP성 환경의 쿼리에 적절 )

소량의 데이터를 가진 쪽이 Outer Table로 설정이 되는 것이 성능에 유리하다.

---
[![image.png](https://i.postimg.cc/KvpT0kNN/image.png)](https://postimg.cc/Yhgj9STG)
---
### 중첩 루프 조인 종류

- **Naive Nested Loops Join** (원시 중첩 루프 조인): 내부 입력에 대해 전체 테이블 또는 인덱스를 스캔(scan)하는 경우
- **Index Nested Loops Join** (인덱스 중첩 루프 조인): 내부 입력에 대해 인덱스를 사용(seek)하는 경우
- **Temporary Index Nested Loops Join** (임시 인덱스 중첩 루프 조인): 내부 입력에 대해 인덱스가 쿼리 계획의 일부로 작성되고 쿼리 완료와 동시에 삭제되는 경우
<br><br><br>

# 2. 정렬 병합 조인( Sort-Merge Join )

![정렬병합](https://github.com/hajaeryul/mvc-20220927-jaeryul/assets/113097210/b79f1fec-1124-4d35-86d5-c933fc562b1f)
---
- 중첩 루프 조인과 비슷하게 중첩 for문과 유사한 방식이긴 하나 차이가 있다.
- 양쪽 테이블을 JOIN 컬럼을 기준으로 **정렬 후** 스캔하여 조인을 수행
- Inner Table 쪽에 적절한 인덱스가 없어서 중첩루프조인을 쓰기에 비효율적일 때 쓰일 수 있다.
- 한 번만 스캔하고 조인을 수행하기 때문에 데이터 처리량이 많을 때 이점이 있으나 정렬 시 메모리 사용이 증가
- **범위 JOIN**에 적절하다 ( 조인 조건으로 <,>등 범위 비교 연산자가 있는 경우)
- 테이블 random access 가 일어나지 않고, 이 sorting 작업이 PGA 영역에서  수행되기 때문에 경합이 발생하지 않아서 성능에 유리한 이점이 있다.

<br><br><br>

# 3. 해시 조인( Hash Join )

![해시매치](https://github.com/hajaeryul/mvc-20220927-jaeryul/assets/113097210/9181e463-75c5-41b5-8d6c-9d6958d1974f)
---
- 배치에서 쓰면 좋은 수행 원리이다 ..
- 대용량 테이블을 JOIN할 때 적절하다
- 두 테이블 중 작은 테이블로 해시 테이블을 생성하고 큰 테이블로 해시 테이블을 탐색하며 조인하는 방식
- 해시 테이블 생성 시 **많은 메모리를 사용**
- Hash영역으로 가는 테이블의 크기가 충분이 작아야 성능이 유리
- **Equal 조인만 가능**
- Sort Merge Join 처럼 Random Access 부하가 없다.

---

### ※주의사항※ <br>

Hash 영역에 들어가는 테이블의 크기가 충분히 작아 성능에 유리

why? Hash 영역의 사이즈가 정해져 있는데 이 테이블의 용량이 그걸 초과해서 벗어나게 돼버리면, 오히려 디스크 영역을 사용하게 되기 때문에 성능에 매우 불리…

그리고 수행 빈도가 높은 OLTP 환경에서 Hash Join으로 풀리게 되면 오히려 CPU 나 메모리의 사용량이 늘어서 성능이 안좋아 질 수도 있다.

⇒ 이런 경우 실행계획을 확인해 보고 Hash Join으로 풀리면 안되는데 Hash Join으로 풀리고 있다면 힌트를 써서 다른 수행 방식으로 풀릴 수 있도록 유도를 하는게 효과적인 튜닝 방법.. 

내가 작성한 Join 쿼리가 어떤 수행 원리로 풀리고 있는지 궁금하다면 실행 계획을 보면 된다!

적절하지 않은 수행 원리가 사용되고 있다면 오라클 힌트를 써서 다른 수행 방식을 유도하자!

---

추가 정보)
## 오라클 힌트??
오라클 힌트란 말 그대로 힌트인데, 옵티마이저에게 주는 힌트이다.
쿼리문 안에 주석처리를 하고 + 기호를 한 뒤 힌트 1개 or 여러개 기술하는 방식으로 힌트를 준다.<br>
ex)  SELECT /* + 힌트1 힌트2 */ FROM  ...

힌트는 잘못 적는다고 해서 쿼리가 syntax 에러가 나지는 않음.. (내부적으로 무시된다.)

옵티마이저에게 주는 힌트이므로, 실행계획에 영향을 미친다.
'이 쿼리를 내부적으로 수행함에 있어서 이러한 방식으로 풀어라... '라고 힌트를 주는거라서
힌트를 주기 앞서서 지금 이 쿼리가 어떻게 실행되고 있는지 확인해야 함..(실행계획을 보고..)

만약에 테이블에 적절한 인덱스가 생성 되어있는데도 옵티마이저가 잘못된 통계 등으로 인해서 인덱스를 타지 않고 풀스캔을 하고 있다?? 
-> 힌트를 줘서 이 테이블엔 이 인덱스 써! 라는 식의 가이드를 옵티마이저에게 줄 수 있다. (약간의 강제성..)

조인 순서, 조인 방식 등에 대해 힌트를 줄 수 있다!


---
### ※주의사항※ <br>

**기본적으로는 힌트를 주지 않는게 좋다!**

why? 우리는 옵티마이저가 기본적으로는 기본적으로는 올바른 판단을 할 것이라는 전제하에 쿼리를 작성해야 하기 때문에 굳이 처음부터 힌트를 줄 필요는 없다.

쿼리를 작성하고 실행계획을 확인했을 때, 예상치보다 너무 많은 I/O가 생긴다든지 시간이 많이 걸린다든지 하는 경우에 실행 계획에서 어느 구간에서 부하가 걸리는지를 확인하고 원인을 분석한 다음에 거기에 알맞은 힌트를 사용하는게 좋다. 

쿼리 작성단계보다는 **튜닝단계에서 힌트를 주로 사용**

--- 

## PGA 영역 ( Program Global Area )
PGA는 데이터베이스에 접속하는 모든 USER에게 할당되는, 각각의 서버 프로세스가 독자적으로 사용하는 오라클 메모리 영역이다.

우선 사용자가 오라클 서버에 접속하면 **사용자 프로세스**가 생성이 된다.

사용자 프로세스는 사용자가 실행시킨 SQL을 서버 프로세스에게 전달하고, 기다렸다가 그 결과를 또 받아서 사용자에게 전달해주는 역할을 한다. (전달자 역할)

**서버 프로세스**는 사용자 프로세스로부터 일을 받아서 그걸 수행하는 오라클과의 상호작용을 담당하게 되는데 PGA는 이 서버 프로세스가 사용하는 메모리이다.

Sort 작업이나 Hash Join을 할 때, PGA의 Sort 영역, Hash 영역을 이용한다.

Sort 작업이 PGA 크기 내에서 완료가 되면 수행속도가 빠르지만 크기를 초과해버리면 디스크에서 Sort가 이루어지기 떄문에 속도가 느려진다.

그 외에도 PGA에는 서버 프로세스가 추출한 결과값을 전달할 유저 프로세스의 세션 정보를 저장하는 세션정보 영역이 있고, 해당 SQL의 Parsing 정보가 담겨있는 주소값을 저장하는 커서 스테이트 영역, SQL 문장에 존재하는 바인드 변수를 저장하는 스택 스페이스 영역이 있다.

참고 : https://dataonair.or.kr/db-tech-reference/d-lounge/technical-data/?mod=document&uid=236107 
