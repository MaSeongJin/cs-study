## http란?

- HTTP(HyperText Transfer Protocol)는 인터넷상에서 정보를 주고받을 수 있는 프로토콜
  
- 클라이언트와 서버 사이에 이루어지는 요청/응답(request/response)을 위한 프로토콜
  
- 주로 일반 텍스트로 이루어진 HTML 문서를 주고받는 데에 사용됨
  

### HTTP의 치명적인 단점, 보안

HTTP는 웹을 지탱하는 심플한 기술이지만 치명적인 단점이 있다. 브라우저와 웹서버가 통신함에 있어서 주고 받는 데이터가 암호화 되지 않고 그대로 전송 되어진다는 점이다.

<p align="center"><img src="https://i.postimg.cc/59BxF3g8/img1-daumcdn.png"></p>

HTTP는 인터넷이라는 통로를 이용해 웹 서버와 브라우저가 서로 통신하게 해주므로, 해커가 그 중간 통로를 도청하게 된다면 중요한 정보들을 탈취할 수 있다. 만약 데이터 일부가 로그인 기능에서 사용하는 아이디 및 비밀번호와 같은 데이터라면  매우 치명적일 수 있다. 더 나아가 해커는 정상 데이터를 중간에서 변조시킬 수도 있다.

## https란?

HTTPS는 Hypertext Transfer Protocol **Secure**(TLS 기반 HTTP 또는 SSL 기반 HTTP) 의 약자이다. HTTPS는 HTTP 요청과 응답을 암호화 하기 위해 TLS(또는 SSL)을 사용하기 때문에 공격자(악성 행위자)는 일반 텍스트 대신 무작위로 보이는 일련의 문자를 볼 수 있다.

<p align="center"><img src="https://i.postimg.cc/KY3f8QLM/img1-daumcdn.png"></p>

통신 암호화 외에도 HTTPS는 두 통신 행위자를 인증하는데 사용된다. HTTP에서는 신뢰의 원칙에 기반하여 신원 확인을 하지 않았지만 현대 인터넷에서는 인증이 필수적이다. 신분증이 신원을 확인하는 것처럼 개인 키는 서버 신원을 확인한다. 예를들면 사용자가 웹 사이트를 탐색할 때 웹 사이트의 SSL 인증서에 있는 공개 키와 일치하는 개인 키를 소유하는 것은 해당 서버가 실제로 웹사이트의 합법적인 호스트임을 증명한다. 이렇게 하면 중간자 공격(Man-in-the-middle attacks), DNS스푸핑(DNS spoofing)등 인증이 없을 때 발생할 수 있는 여러 공격을 방지하거나 차단할 수 있다.

> DNS스푸핑은 DNS서버를 통해 특정 웹서버의 주소로 번역하는 과정에서 이를 가로채서 공격자가 원하는 위조된 웹서버로 접근하게 하는 방법이다.

## SSL과 TLS

SSL은 **클라이언트와 서버가 서로 데이터를 암호화해 통신할 수 있도록 돕는 보안 계층**이다.

HTTPS를 사용하면 HTTP 메시지에 포함되는 콘텐츠 정보에 보안 요소가 추가되기 때문에 데이터를 안전하게 주고받을 수 있는 것이다. OSI 계층 구조로 보자면 HTTPS는 아래 그림과 같이 HTTP 계층 아래에 SSL이라는 보안 계층이 추가된 모습을 볼 수 있다. 기본 포트는 TCP 443을 사용한다.

<p align="center"><img src="https://i.postimg.cc/NGRdqN79/img1-daumcdn.jpg"></p>

OSI의 각 계층은 서로 독립되어 있기 때문에 SSL 또한 HTTPS뿐만 아니라 파일 전송을 위한 FTP, 이메일 전송에 사용되는 SMTP들과 조합해서 사용할 수도 있다.

그리고 SSL을 검색해보면 **TLS(Transport Layer Security)** 라는 단어가 함께 따라다니는 것을 종종 볼 수 있다. 사실 이 둘은 약간의 차이는 있지만 같은 보안 프로토콜에서 시작했다.

**SSL와 TLS가 다른 이름으로 불려지게된 계기**

원인은 SSL이 갓 알려지기 시작한 1990년대 후반으로 거슬러 올라가 찾아볼 수 있다. 당시 공개된 SSL 2.0에 몇 가지 취약점이 발견되어 이를 해결하기 위해 아예 구조를 재설계해 SSL3.0을 배포했는데, 그 이후 기존 버전과 구분하기 위해 3.0 다음부터 등장한 SSL의 이름을 TLS로 변경했다. 다만 사람들이 SSL이란 이름에 더 익숙하다 보니, 대다수의 보안 프로토콜이 TLS로 교체되어 더 이상 SSL을 사용하고 있지 않은 지금까지도 계속 SSL이라고 부르고 있는 것이다.

## SSL 동작 방식

### 대칭키, 공개키로 암호화하기

<p align="center"><img src="https://i.postimg.cc/659gHJJ5/img1-daumcdn.jpg"></p>

**대칭키 기법**은 **하나의 키로 암호화와 복호화를 둘 다 할 수 있는 암호화 기법**이다.

예를 들면 보물 상자에 하나의 열쇠 구멍이 있고, 거기에 맞는 열쇠 하나로 보물 상자를 열고 잠글 수 있는 것과 같다.

웹 통신으로 생각해보면 클라이언트와 서버가 각각 '1234'라는 키를 갖고 있다가 데이터가 왔을 때 이 키로 복호화를 하고, 데이터를 보낼 땐 같은 키를 가지고 암호화를 해 전송하는 것이다.

이런 대칭키 기법은 뒤에 설명할 공개키 방식에 비해 암호화나 복호화에 속도가 빠르다는 장점이 있지만, 키를 안전하게 서로 교환하기 어렵다는 단점이 있다.

왜냐하면 클라이언트와 서버가 같은 키를 갖고 있어야 하므로 서로 키를 통신해야 하는데, 그럼 중간에 누가 키를 가로챌 위험이 있기 때문이다.

이러한 대칭키 기법의 문제를 해결하기 위해 탄생한 암호화 방식이 바로 **공개키 기법**이다.

공개키 기법은 **서로 다른 키 두 개로 암호화, 복호화를 한다는 특징**이 있다. 이때 사용하는 키 두 개를 각각 **공개키, 개인키**라고 부른다. 공개키는 누구나 가질 수 있는 키지만 개인키는 소유자 한 명만 가질 수 있는 키로 이 두 키는 늘 한 쌍으로 동작한다. 이 때문에 공개키 암호화 기법을 위해서는 반드시 공개키와 개인키가 함께 필요하다.

<p align="center"><img src="https://i.postimg.cc/dVckMB61/img1-daumcdn.png"></p>

공개키의 보물 상자가 대칭키와 다른 점이 있다면 **각기 다른 형태인 열쇠 두 개가 한 쌍으로 이루어져 있다는 점**이다. 이해하기 쉽게 각각 빨간 열쇠와 파란 열쇠라고 부르도록 하겠다.

이때 만약 보물 상자를 빨간 열쇠로 잠갔다면 남아있는 파란 열쇠로만 상자를 열 수 있다. 반대로 파란 열쇠로 상자를 잠갔다면 남은 빨간 열쇠로만 열 수 있다.

공개키 기법도 이와 마찬가지이다. **공개키로 암호화한 데이터는 개인키로만 복호화할 수 있고, 반대로 개인키로 암호화한 데이터는 공개키로만 복호화 할 수 있다.**

그래서 만약 서버가 개인키를 갖고, 클라이언트에게 공개키를 전달해 서로 데이터를 암호화해서 주고받는다면 중간에 누군가 공개키를 가로챘다고 하더라도 개인키를 모르기 때문에 데이터를 온전히 복호화할 수 없다.

따라서 대칭키보다 더 안전하게 데이터를 주고받을 수 있다는 점에서 장점이 있지만, 암호화 과정이 복잡하므로 속도가 느리다는 단점이 있다.

이처럼 공개키 기법과 대칭기 기법은 언뜻 비슷해 보이지만 각자 뚜렷한 특징을 갖고 있는데, **SSL에서는 이 두 기법을 함께 사용**하며 서로의 단점을 보완할 수 있게 하였다.

## SSL 동작 과정

SSL은 크게 **핸드 셰이크, 세션, 세션 종료 세 단계**로 이루어진다.

TCP와 유사하게 SSL도 클라이언트와 서버가 통신할 때 준비가 되었는지 확인하는 과정인 핸드 셰이크를 거친다.

<p align="center"><img src="https://i.postimg.cc/j5x3MPm3/img1-daumcdn.jpg"></p>

- **1단계:**  클라이언트는 서버에게 인사를 건넨다. 과정 이름도 Client Hello이다. 이때 **랜덤한 데이터와 현재 지원할 수 있는 암호화 방식을 서버에게 전달**한다. 암호화 방식을 전달하는 이유는 같은 대칭키, 공개키 기법이라도 다양한 암호화 방식이 있으므로 서로 어떤 암호화 방식을 사용할지 협의하는 과정이 필요하기 때문이다.
  
- **2단계:** 클라이언트의 인사를 받은 서버는 똑같이 클라이언트에게 인사를 한다. 이때 서버는 세 가지 내용을 전달한다. 앞서 클라이언트가 전달한 내용과 동일한 **랜덤 데이터와 지원 가능한 암호화 방식, 그리고 새롭게 등장하는 개념인 인증서를 전달**한다.
  
  인증서란 서버가 공식으로 인증된 기관인 CA(Certificate Authority)에서 발급받은 문서로, 서버가 신뢰할 수 있는지 보장하는 역할이다. 제품으로 따지면 품질보증서 같은 존재인 것이다.
  
- **3단계:** 인증서를 받은 클라이언트는 이 인증서가 제대로 된 문서인지 검증하기 위해, **CA가 발급한 인증서 목록 중에서 서버가 전달한 인증서가 있는지 확인**한다. 그리고 인증서가 목록에 있다면 한 번 더 철저히 확인하기 위해 CA에서 공유하는 공개키를 가지고 **인증서를 복호화**한다. 만약 복호화에 성공한다면 이 인증서는 서버가 자신의 비밀키로 암호화를 했다는 것이 검증되니 드디어 서버를 신뢰할 수 있는 것이다.
  
- **4단계:** 본격적으로 키를 주고받기 위해 클라이언트는 실제 데이터 통신에서 사용할 **대칭키를 임시로 만듭니다.** 이때 앞서 클라이언트와 서버가 서로 주고받은 랜덤한 데이터를 조합해 임시 키(pre master secret)를 생성하는데, 임시 키는 대칭키이기 때문에 절대 중간에 제 3자에게 노출되어선 안 됨으로 앞서 갖고 있던 공개키로 암호화해 서버에게 전달한다.
  
- **5단계:** 키를 받은 서버는 자신이 갖고 있던 개인키로 암호를 해독해 **임시 키를 전달받게 된다.** 비로소 클라이언트와 서버가 같은 키를 갖게 된 것이다.
  
- **6단계:** 클라이언트와 서버의 임시 키는 일련의 과정을 거쳐 **세션 키**로 바뀌고, 이 세션 키를 이용해 **본격적으로 클라이언트와 서버가 통신**을 할 수 있게 됩니다.
  
- 그 이후 단계인 세션 단계에서는 앞서 생성한 세션 키를 이용해 대칭키 기법으로 데이터를 암호화해서 통신하고, 데이터 전송이 끝나면 세션을 종료해 통신을 마친다. 이때 통신에서 사용한 세션 키도 함께 삭제한다.
  

<p align="center"><img src="https://i.postimg.cc/ZRyk8rNk/img1-daumcdn.png"></p>
