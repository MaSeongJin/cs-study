## HTTP의 진화 과정
![image](https://github.com/NoRuTnT/practice/assets/114069644/5a27250a-6f08-4737-ab94-56408e8c6c1c)  

## 표준이전의 HTTP

HTTP/1.1 이전에는 HTTP/1.0과 HTTP/0.9라는 두개의 버전이 존재했다.
> HTTP/0.9 : 문서화된 최초의 HTTP버전  
> HTTP/1.0 : 기존 HTTP의 기능을 확장한 버전  
> HTTP/1.1 : 표준화된 HTTP  

## HTTP/0.9
HTTP/1.1을 알기위해서는 표준이전의 HTTP에 대해서도 알아야한다.
초창기의 웹은 아주 단순한 서버-클라이언트 구조를 따랐다. 클라이언트에서 HTTP을 달라고 서버에게 HTTP규격에 맞추어 요청을 보내면, 서버가 그에맞는 HTTP을 전송하는 것이 전부였다.  
이러한 HTTP는 처음부터 TCP/IP위에서 구현되도록 설계되었다.  
지금은 TCP가 무겁고 느리다고 많이 까이지만, 당시만해도 TCP는 연결지향적인 특성때문에 UDP에 비해 안정적이고 신뢰성있는 통신을 제공했기때문이다.  
그러다보니 당시 HTTP의 구조는 매우간단했다. 요청 메서드 종류도 GET한가지 뿐이었고 헤더나 상태코드도 없었다.  
응답은 무조건 HTTP파일 그자체였다.
![image](https://github.com/NoRuTnT/practice/assets/114069644/410cc2cb-74a4-4755-a508-ee0ad3b09759)  
그런데 웹이 인기를 끌다보니 기존의 HTTP사양 만으로는 사용자들의 모든 요구사항을 충족할수없게되었고  
그러다보니 여러브라우저와 웹서버벤더는 각자 HTTP에 여러가지 기능을 추가했고 명시적으로 약속된 사양이 없어 이들간의 혼란이 발생하였다.  
그래서 HTTP의 기본적인 구조는 그대로 유지하면서도 다양한 요구사항을 충족시키고 표준화하기위해 HTTP WG(working group)라는 조직이 탄생한다.    
1996년에 이러한 사양을 정리하여 발표했는데 이를 HTTP/1.0이라고 부르고 구별을 위해 최초의버전은 HTTP/0.9라는 이름을 붙였다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/b2a6066c-556e-496c-9724-c0c23dbe2da7)    

## HTTP/1.0
 
![image](https://github.com/NoRuTnT/practice/assets/114069644/3be79089-3b4a-4986-a65a-a37f15de4772)  
HTTP/1.0에서 주목할만한 몇가지 사항이다.  
> - 버전정보가 명시되었고 각 요청, 응답사이에서 전송되었다.  
> - 요청 메서드가 GET, HEAD, POST 세 가지로 확장되었다.  
> - 상태 코드가 추가되어 클라이언트 측에서 요청 결과에따라 동작할수있게 되었다.  
> - 요청과 응답에 대한 부가적인 메타데이터를 담는 헤더필드가 추가되었다.  
> - HTTP헤더의 도움으로 HTTP이외의 파일도 전송할수있게되었다.

![image](https://github.com/NoRuTnT/practice/assets/114069644/eb10427a-a27b-48cc-9489-7c8037c1aeb0)


## HTTP/1.1  

사실 HTTP WG는 HTTP/1.0 사양을 정리하는 동시에 좀더 표준화된 사양인 HTTP/1.1의 초안을 제작하고있었다.  
브라우저와 서버 개발자들은 제작중인 초안을 참고하여 새 표준이 될 HTTP의 기능을 미리 구현해 놓았다.  
그래서 HTTP/1.1은 HTTP/1.0이 나온지 얼마 지나지않은 1997년에 발표될수 있었다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/1665e545-9fc9-40c6-9f4e-e7db54ef220b)  
HTML/1.1의 제안 배경을 살펴보면 크게 두가지의 문제가 있었던 모양이다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/2d8fc5a1-3187-4077-a8eb-b6f3980e7718)  
> - HTML/1.0 설계에서 불완전하고 미처 고려되지못한 부분(계층적프록시,캐싱,연결지속 등)이 있어서 보완해야한다.  
> - HTML/1.0으로 통신한다고 선언해 놓고 사양을 지키지않은 서버와 클라이언트가 많다보니 불편함.

따라서 HTTP/1.1에서는 이러한 문제들을 해결하기위해 다음과같은 사항들이 추가되었습니다.

### 연결상태유지(persisted connection)
HTTP/1.0 에서는 요청에 따른 응답이 수신되면 TCP연결을 바로 종료한다. 초창기의 웹에는 이게 문제가 없었지만 웹 페이지가 복잡해지다 보니 문제가 되기시작했다.  
웹페이지에서 다수의 HTTP요청이 발생하는 경우 매번 TCP핸드셰이크 과정을 새로거쳐야 해서 속도가 느려졌기때문이다.  
게다가 TCP자체의 흐름제어와 혼잡제어 알고리즘으로 인해 네트워크성능이 100% 나오지않았다.  

그래서 HTTP/1.1에서는 기본적으로 한번 수립한 연결을 재사용하게 설정되어있다.  
이렇게되면 연결을 맺고 끊는 과정이 줄어들기 때문에 지연이 개선될 수 있다.  
물론 연결을 유지하는 시간이 길어질수록 서버에 부하가 생기기 때문에 연결을 유지하는 시간을 제한하고있으며 이를 Keep-Alive라고 부른다.  

![image](https://github.com/NoRuTnT/practice/assets/114069644/320dc277-de3d-455d-ba72-b7a6ecfb33a7)  
![image](https://github.com/NoRuTnT/practice/assets/114069644/0cb93fc1-ecdc-4510-b749-294843841861)  

### 파이프라이닝(Pipelining)
파이프 라이닝은 클라이언트가 여러요청을 연달아 보내야 할때, 각 응답을 기다리는 것이 아니라 발생한 요청은 일단 전송하고 보는 방식이다.  
기존에는 여러 요청이 있을 때 하나의 요청과 그 응답을 세트로 반복하면서 처리하는 것을 볼 수있는데 이것이 지연을 발생시키고있는걸 볼수있다.  

그래서 HTTP/1.1에서는 파이프라이닝 기법을 사용한다. 일단 클라이언트 측에서 여러 요청을 순차적으로 보내면, 서버는 받은 순서에 따라 응답을 제공하는 방식으로 지연을 개선하는 것이다.  
이때 각 요청별 응답을 구분하기위해 순서를 엄격히 지켜야한다.  

이외에도 HTTP을 분할해 전송하는 청크전송인코딩이나 요청과 응답에 대한 메타정보를 답는 캐시제어, 동일 IP에 여러 도메인을 호스트 할 수있게 해주는 호스트등의 헤더와 기능이 추가되었다.  


![image](https://github.com/NoRuTnT/practice/assets/114069644/72f93d67-4c3c-4af2-b1de-f1b45678c28b)
![image](https://github.com/NoRuTnT/practice/assets/114069644/040fdde2-fa52-4044-8b93-9a6e8b344f98)

![image](https://github.com/NoRuTnT/practice/assets/114069644/45817af4-dfa8-41b1-8f7b-b83f3637d2fe)  

## HTTP/2
HTTP/1.1이 발표된 1997년 이후로 HTTP는 꾸준히 확장되었고, 그 사이 웹은 더욱 복잡해졌다.   
그러다보니 HTTP/1.1만으로는 극복할 수 없는 한계점이 점점 드러나기 시작했다.  
우선 헤더의 중복이다. HTTP/1.1에 다양한 기능이 추가되면서 헤더에도 많은 메타 데이터가 담기게 되었다. 하지만 매 요청마다 헤더를 중복해서 전송해야만 했는데, 이것이 굉장한 낭비로 이어졌다.  
하지만 무엇보다도 가장 큰 문제는 서버가 항상 요청받은 순서대로 응답해야 하므로 발생하는 HOLB(Head-of-Line Blocking)였다.  
HTTP/1.1에서는 하나의 연결 내에서 응답 다중화(multiplexing)를 할 수 없었기 때문에 요청이 순차적으로 처리되어야 했는데, 서버가 응답 작성 중간에 문제가 생기면 후속 요청들이 전송되지 못하고 지연되는 문제가 있었던 것이다.  
결국 HTTP/1.1 방식에는 물리적인 TCP 연결을 여러 개 두는 방식으로 병렬 연결을 구현하게 되었다. 브라우저마다의 정책도 다른데 일반적으로 최대 6개의 동시 TCP 연결을 지원한다는 것으로 알려져 있다.  
하지만 이 방식 역시 임시적인 해결책일 뿐 HTTP/1.1의 HOLB를 해결할 수 있는 해결책은 아니었습니다.  
이 외에도 요청 별 우선순위를 지정할 수 없고, 클라이언트 기반 통신이기 때문에 서버에서 클라이언트 측으로 데이터를 전송할 수 있는 기능이 없다는 등의 문제가 있었습니다.  
HTTP/2는 이러한 한계를 극복하기 위해 2015년 국제 표준으로 등장했습니다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/c15f61eb-4618-4395-9a6a-0438da74e1d2)  
우선 HTTP/2는 SPDY라는 프로토콜을 기반으로 동작한다. SPDY는 HTTP/1.1의 잘알려진 성능제한사항을 해결하여 웹페이지의 로드 대기시간을 줄이는 것을 목표로 구글에서 개발하고 2009년 중반에 발표한 프로토콜이다.  
때문에 HTTP/2는 HTTPoverSPDY라는 이름으로도 불린다.  
이러한 HTTP/2는 기존 프로토콜과 호환성을 유지하면서, HTTP/1.1의 문제를 해결하기위해 여러특징을 가지고있다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/7dc1ff36-b3b7-47e6-bf0e-f9828dcd38d6)  
첫 번째로 HTTP/2는 **이진(binary) 프로토콜**이다. HTTP/1.1은 텍스트 기반 프로토콜이기 때문에 아스키코드로 작성되었다. 덕분에 사람이 읽기에는 편하지만, 불필요하게 데이터가 커지는 문제가 있었다.  
HTTP/2에서는 보내야 할 데이터를 바이너리로 변환하는 계층이 있기 때문에 단순 텍스트를 전송하는 것보다 훨씬 더 효율적으로 데이터를 전송할 수 있습니다.  
이것은 사실 HTTP/2의 버전이 HTTP/1.2가 아닌 이유이기도 한데, 예전처럼 텍스트 기반의 전송이 아닌 바이너리 프레이밍을 사용하기 때문이다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/1841be34-a3e2-410f-9c72-49a0320ee628)  
두번째로 HTTP/2는 **응답 다중화**(multiplexing)를 지원한다. HTTP/1.1에서는 TCP연결에서 한번에 하나의 요청만 처리가능하며 요청별 순서를 반드시 지켜야 했던 것과는 대조적이다.  
HTTP/2에서는 하나의 TCP연결에서 여러요청을 동시에 처리할 수 있는데 이것은 TCP 연결을 스트림,메세지,프레임이라는 단위로 세분화했기때문이다.  
> - 스트림 : 요청과 응답이 양방향으로 오가는 논리적 연결 단위, TCP연결에서 여러개의 스트림이 동시에 존재할수있다.
> - 메세지 : 하나의 요청과 응답을 구성하는 단위
> - 프레임: 메세지를 구성하는 최소단위, 잘게쪼개어 전송되기때문에 수신측에서 다시 조립하여 사용

![image](https://github.com/NoRuTnT/practice/assets/114069644/2484df33-81d3-4608-b043-3d9aae8ac576)
위의 사진에는 하나의 TCP 연결 내에 3개의 스트림이 있는 것을 볼 수 있다. 그중 5번 스트림은 클라이언트측에서 서버로 데이터를 전송 중이며, 1, 3번 스트림은 서버 측에서 클라이언트로 데이터를 전송 중이다.  
또한 3번 스트림의 프레임이 1번 프레임 사이에 끼어들어 있는 것을 볼 수 있습. 클라이언트 측에서는 이것을 다 시 조립하여 사용한다.  
이러한 응답 다중화 기능 덕분에 HTTP/1.1에서 발생한 HOLB 문제를 해결할 수 있었다.  

![image](https://github.com/NoRuTnT/practice/assets/114069644/5d6bc2bd-f5b2-42e2-9019-d29a8fbe21ca)  
세 번째로 HTTP/2는 헤더 필드 압축을 지원한다. 이를 HPACK이라 부르는데, 달라진 부분만 다시 전송하는 허프만 코딩(Huffman Coding) 기법을 사용한다.  
달라지지 않은 부분은 전송하지 않기 때문에 불필요하게 발생하는 오버헤드를 최소화할 수 있다.  
이 외에도 HTTP/2에는 서버가 클라이언트가 요청하지 않은 리소스를 미리 클라이언트에게 보낼 수 있는 서버푸시 기능, 정수와 트리 구조로 구현된 스트림별 우선순위 지정 기능, 프로토콜 자체의 흐름 제어 기능 등이 포함 되어 있다.


## HTTP/3
![image](https://github.com/NoRuTnT/practice/assets/114069644/5a3528ee-3412-43d7-ae18-bb4dd4140993)  
그런데 HTTP/2가 발표된 지 채 4년도 지나지 않아 HTTP/3가 발표되었고, 2022년 6월 22일에는 최종적으로 표준이 확정되었다. HTTP/2가 나온 지도 얼마 되지 않았는데, HTTP/3는 어떤 문제점을 해결하기 위해 등장한 걸까?  
그 이유는 HTTP/2가 여전히 TCP 위에서 동작하기 때문에 TCP로 인해 발생하는 문제를 해결할 수 없었기 때문이다. 우선 TCP는 신뢰성을 지향하기 때문에 데이터손실이 발생하면 재전송을 수행한다.  그런데 TCP는 패킷을 정확한 순서대로 처리해야 하기 때문에 재전송을 수행하고 대기하는 과정에서 병목 현상이 발생한다. 즉, TCP라는 프로토콜 자체의 HOLB 문제를 해결할 수 없었다.  
또한 TCP는 혼잡 제어를 수행하기 때문에 전송 속도를 낮은 상태에서 천천히 높이는 방식으로 속도 제어를 취한다. 이는 네트워크 상황이 좋을 때는 불필요한 지연을 발생시킨다. 그리고 프로토콜 자체의 불필요한 헤더 등도 고칠 수가 없었다. 결국 TCP는 현대 사회에 어울리지 않은 프로토콜이었던 것이다.  

이러한 문제를 해결하기 위해 HTTP/3는 QUIC이라는 프로토콜 위에서 동작한다. QUIC는 TCP의 신뢰성 보장을 위해 제공되는 기능들을 UDP 기반으로 직접 구현하여 성능을 개선한, 구글이 2013년에 공개한 프로토콜 이다. 따라서 HTTP/3는 HTTP over QUIC이라는 이름으로도 불린다.
![image](https://github.com/NoRuTnT/practice/assets/114069644/007c318f-28d9-4b95-b970-8b1e3e613efc)  
QUIC는 TCP가 아닌 UDP 기반의 프로토콜이라는 점에 주목하지 않을 수 없다. 사실 UDP는 TCP와 달리 기본적인 신뢰성을 제공하지 않는데, UDP 프로토콜 자체의 구조가 간단하기 때문에 QUIC는 신뢰성을 위해 패킷 재전송, 혼잡 제어, 흐름 제어 기능 등을 직접 구현했다. 즉 QUIC는 신뢰성 기능이 제공되는 UDP 기반 의 프로토콜이다.  
HTTP/3는 QUIC이라는 UDP 기반 프로토콜을 사용하기 때문에 TCP 기반의 HTTP/2에서 해결하지 못한 문제점을 해결할 수 있었다.  

![image](https://github.com/NoRuTnT/practice/assets/114069644/0f75595a-3b34-47b0-862a-e59c3f86f061)  
우선 HTTP/3는 연결 정보를 캐싱하여 재사용할 수 있는 O-RTT 기능을 제공한다. TCP의 경우 최초 연결 수립시 3-way 핸드셰이크 과정이 필요하지만, HTTP/3는 최초 연결 설정에서 연결에 필요한 정보들과 데이터를 함께 전송하여 1-RTT로 시간을 절약한다. 또한 한번 성공한 연결은 캐싱해 놓았다가 다음 연결 때에는 캐싱된 정보를 바탕으로 바로 연결을 수립할 수 있기 때문에 O-RTT가 가능하다.  

![image](https://github.com/NoRuTnT/practice/assets/114069644/a45ac710-727c-4bf6-86e0-a373ad336932)  
또한 HTTP/3는 연결 다중화를 지원하며, 각 스트림이 독립적으로 동작한다. 위 사진을 보면 각 스트림이 독립적으로 동작한다는 것이 어떤 의미인지 쉽게알 수 있을 것이다.  
HTTP/2에서는 연결 다중화가 지원되어 여러스트림을 동시에 지원할 수 있지만, TCP 특성상 데이터 손실이 발생하면 데이터 복구를 우선 처리하면서 HOLB가 발생한다. 하지만 QUIC 기반의 HTTP/3는 연결내 스트림이 완전히 독립적으로 동작하기 때문에 데이터 손실이 발생해도 다른 스트림에 영향을 주지 않는다.  
그리고 HTTP/3는 IP 기반이 아닌, 연결별 고유 UUID(Connection ID)를 이용해 각 연결을 식별한다. TCP 기반 통신의 경우에는 Wi-Fi 환경에서 셀룰러 환경으로 이동하는 경우 IP 주소가 변경되기 때문에 연결 재수립 과정을 거쳐야 하지만, QUIC는 연결 ID 기반으로 식별하기 때문에 연결을 그대로 유지할 수 있다.  
HTTP/2와 마찬가지로 TLS 연결 설정 과정이 QUIC 내부에 포함되기 때문에 HTTP/3는 HTTPS 사용이 강제되고, 우선순위 제어, 서버 푸시 등의 기능을 제공한다.  
HTTP/3의 헤더 프레임은 HTTP/2.0의 HPACK과 유사하게 QPACK을 이용해 압축되어 전송된다. QUIC의 스트림이 독립적으로 송수신함에 따라 이에 맞춰 개선된 것 정도로 이해하면 된다.
마지막으로 기존 HTTP 체계와 호환되기 때문에, TCP 기반 통신 중 HTTP/3가 지원된다면 서버가 이를 클라이언트 측에 이를 알려 HTTP/3 방식의 통신으로 전환을 유도할 수 있기도 하다.

## 요약
> HTTP/1.1 : ASCII over TCP
> HTTP/2 : Binary Multiplexed over SPDY(TCP)
> HTTP/3 : Binary over Multiplexed QUIC(UDP)


## 면접질문으로 나온다면
HTTP2.0은 HTTP1.1과 호환이 되지 않을 정도로 변화했는데 어떤 부분에서 변화한 것일까? 
어떤 등장 배경이 있고 어떻게 효율성이 증가되었는지, 왜 호환이 안되는지 등등
HTTP의 전체적인 발전 과정을 알지 못한다면 대답하기 힘들수도..
