## HTTP의 진화 과정
![image](https://github.com/NoRuTnT/practice/assets/114069644/5a27250a-6f08-4737-ab94-56408e8c6c1c)  

## 표준이전의 HTTP

HTTP/1.1 이전에는 HTTP/1.0과 HTTP/0.9라는 두개의 버전이 존재했다.
> HTTP/0.9 : 문서화된 최초의 HTTP버전  
> HTTP/1.0 : 기존 HTTP의 기능을 확장한 버전  
> HTTP/1.1 : 표준화된 HTTP  

## HTTP/0.9
HTTP/1.1을 알기위해서는 표준이전의 HTTP에 대해서도 알아야한다.
초창기의 웹은 아주 단순한 서버-클라이언트 구조를 따랐다. 클라이언트에서 HTTP을 달라고 서버에게 HTTP규격에 맞추어 요청을 보내면, 서버가 그에맞는 HTTP을 전송하는 것이 전부였다.  
이러한 HTTP는 처음부터 TCP/IP위에서 구현되도록 설계되었다.  
지금은 TCP가 무겁고 느리다고 많이 까이지만, 당시만해도 TCP는 연결지향적인 특성때문에 UDP에 비해 안정적이고 신뢰성있는 통신을 제공했기때문이다.  
그러다보니 당시 HTTP의 구조는 매우간단했다. 요청 메서드 종류도 GET한가지 뿐이었고 헤더나 상태코드도 없었다.  
응답은 무조건 HTTP파일 그자체였다.
![image](https://github.com/NoRuTnT/practice/assets/114069644/410cc2cb-74a4-4755-a508-ee0ad3b09759)  
그런데 웹이 인기를 끌다보니 기존의 HTTP사양 만으로는 사용자들의 모든 요구사항을 충족할수없게되었고  
그러다보니 여러브라우저와 웹서버벤더는 각자 HTTP에 여러가지 기능을 추가했고 명시적으로 약속된 사양이 없어 이들간의 혼란이 발생하였다.  
그래서 HTTP의 기본적인 구조는 그대로 유지하면서도 다양한 요구사항을 충족시키고 표준화하기위해 HTTP WG(working group)라는 조직이 탄생한다.    
1996년에 이러한 사양을 정리하여 발표했는데 이를 HTTP/1.0이라고 부르고 구별을 위해 최초의버전은 HTTP/0.9라는 이름을 붙였다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/b2a6066c-556e-496c-9724-c0c23dbe2da7)    

## HTTP/1.0
 
![image](https://github.com/NoRuTnT/practice/assets/114069644/3be79089-3b4a-4986-a65a-a37f15de4772)  
HTTP/1.0에서 주목할만한 몇가지 사항이다.  
> - 버전정보가 명시되었고 각 요청, 응답사이에서 전송되었다.  
> - 요청 메서드가 GET, HEAD, POST 세 가지로 확장되었다.  
> - 상태 코드가 추가되어 클라이언트 측에서 요청 결과에따라 동작할수있게 되었다.  
> - 요청과 응답에 대한 부가적인 메타데이터를 담는 헤더필드가 추가되었다.  
> - HTTP헤더의 도움으로 HTTP이외의 파일도 전송할수있게되었다.

![image](https://github.com/NoRuTnT/practice/assets/114069644/eb10427a-a27b-48cc-9489-7c8037c1aeb0)


## HTTP/1.1  

사실 HTTP WG는 HTTP/1.0 사양을 정리하는 동시에 좀더 표준화된 사양인 HTTP/1.1의 초안을 제작하고있었다.  
브라우저와 서버 개발자들은 제작중인 초안을 참고하여 새 표준이 될 HTTP의 기능을 미리 구현해 놓았다.  
그래서 HTTP/1.1은 HTTP/1.0이 나온지 얼마 지나지않은 1997년에 발표될수 있었다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/1665e545-9fc9-40c6-9f4e-e7db54ef220b)  
HTML/1.1의 제안 배경을 살펴보면 크게 두가지의 문제가 있었던 모양이다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/2d8fc5a1-3187-4077-a8eb-b6f3980e7718)  
> - HTML/1.0 설계에서 불완전하고 미처 고려되지못한 부분(계층적프록시,캐싱,연결지속 등)이 있어서 보완해야한다.  
> - HTML/1.0으로 통신한다고 선언해 놓고 사양을 지키지않은 서버와 클라이언트가 많다보니 불편함.

따라서 HTTP/1.1에서는 이러한 문제들을 해결하기위해 다음과같은 사항들이 추가되었습니다.

### 연결상태유지(persisted connection)
HTTP/1.0 에서는 요청에 따른 응답이 수신되면 TCP연결을 바로 종료한다. 초창기의 웹에는 이게 문제가 없었지만 웹 페이지가 복잡해지다 보니 문제가 되기시작했다.  
웹페이지에서 다수의 HTTP요청이 발생하는 경우 매번 TCP핸드셰이크 과정을 새로거쳐야 해서 속도가 느려졌기때문이다.  
게다가 TCP자체의 흐름제어와 혼잡제어 알고리즘으로 인해 네트워크성능이 100% 나오지않았다.  

그래서 HTTP/1.1에서는 기본적으로 한번 수립한 연결을 재사용하게 설정되어있다.  
이렇게되면 연결을 맺고 끊는 과정이 줄어들기 때문에 지연이 개선될 수 있다.  
물론 연결을 유지하는 시간이 길어질수록 서버에 부하가 생기기 때문에 연결을 유지하는 시간을 제한하고있으며 이를 Keep-Alive라고 부른다.  

![image](https://github.com/NoRuTnT/practice/assets/114069644/320dc277-de3d-455d-ba72-b7a6ecfb33a7)  
![image](https://github.com/NoRuTnT/practice/assets/114069644/0cb93fc1-ecdc-4510-b749-294843841861)  

### 파이프라이닝(Pipelining)
파이프 라이닝은 클라이언트가 여러요청을 연달아 보내야 할때, 각 응답을 기다리는 것이 아니라 발생한 요청은 일단 전송하고 보는 방식이다.  
기존에는 여러 요청이 있을 때 하나의 요청과 그 응답을 세트로 반복하면서 처리하는 것을 볼 수있는데 이것이 지연을 발생시키고있는걸 볼수있다.  

그래서 HTTP/1.1에서는 파이프라이닝 기법을 사용한다. 일단 클라이언트 측에서 여러 요청을 순차적으로 보내면, 서버는 받은 순서에 따라 응답을 제공하는 방식으로 지연을 개선하는 것이다.  
이때 각 요청별 응답을 구분하기위해 순서를 엄격히 지켜야한다.  

이외에도 HTTP을 분할해 전송하는 청크전송인코딩이나 요청과 응답에 대한 메타정보를 답는 캐시제어, 동일 IP에 여러 도메인을 호스트 할 수있게 해주는 호스트등의 헤더와 기능이 추가되었다.  


![image](https://github.com/NoRuTnT/practice/assets/114069644/72f93d67-4c3c-4af2-b1de-f1b45678c28b)
![image](https://github.com/NoRuTnT/practice/assets/114069644/040fdde2-fa52-4044-8b93-9a6e8b344f98)

![image](https://github.com/NoRuTnT/practice/assets/114069644/45817af4-dfa8-41b1-8f7b-b83f3637d2fe)  

## HTTP/2
HTTP/1.1이 발표된 1997년 이후로 HTTP는 꾸준히 확장되었고, 그 사이 웹은 더욱 복잡해졌다.   
그러다보니 HTTP/1.1만으로는 극복할 수 없는 한계점이 점점 드러나기 시작했다.  
우선 헤더의 중복이다. HTTP/1.1에 다양한 기능이 추가되면서 헤더에도 많은 메타 데이터가 담기게 되었다. 하지만 매 요청마다 헤더를 중복해서 전송해야만 했는데, 이것이 굉장한 낭비로 이어졌다.  
하지만 무엇보다도 가장 큰 문제는 서버가 항상 요청받은 순서대로 응답해야 하므로 발생하는 HOLB(Head-of-Line Blocking)였습니다.  
HTTP/1.1에서는 하나의 연결 내에서 응답 다중화(multiplexing)를 할 수 없었기 때문에 요청이 순차적으로 처리되어야 했는데, 서버가 응답 작성 중간에 문제가 생기면 후속 요청들이 전송되지 못하고 지연되는 문제가 있었던 것이다.  
결국 HTTP/1.1 방식에는 물리적인 TCP 연결을 여러 개 두는 방식으로 병렬 연결을 구현하게 되었다. 브라우저마다의 정책도 다른데 일반적으로 최대 6개의 동시 TCP 연결을 지원한다는 것으로 알려져 있다.  
하지만 이 방식 역시 임시적인 해결책일 뿐 HTTP/1.1의 HOLB를 해결할 수 있는 해결책은 아니었습니다.  
이 외에도 요청 별 우선순위를 지정할 수 없고, 클라이언트 기반 통신이기 때문에 서버에서 클라이언트 측으로 데이터를 전송할 수 있는 기능이 없다는 등의 문제가 있었습니다.  
HTTP/2는 이러한 한계를 극복하기 위해 2015년 국제 표준으로 등장했습니다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/c15f61eb-4618-4395-9a6a-0438da74e1d2)  
우선 HTTP/2는 SPDY라는 프로토콜을 기반으로 동작한다. SPDY는 HTTP/1.1의 잘알려진 성능제한사항을 해결하여 웹페이지의 로드 대기시간을 줄이는 것을 목표로 구글에서 개발하고 2009년 중반에 발표한 프로토콜이다.  
때문에 HTTP/2는 HTTPoverSPDY라는 이름으로도 불린다.  
이러한 HTTP/2는 기존 프로토콜과 호환성을 유지하면서, HTTP/1.1의 문제를 해결하기위해 여러특징을 가지고있다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/7dc1ff36-b3b7-47e6-bf0e-f9828dcd38d6)  
첫 번째로 HTTP/2는 **이진(binary) 프로토콜**이다. HTTP/1.1은 텍스트 기반 프로토콜이기 때문에 아스키코드로 작성되었다. 덕분에 사람이 읽기에는 편하지만, 불필요하게 데이터가 커지는 문제가 있었다.  
HTTP/2에서는 보내야 할 데이터를 바이너리로 변환하는 계층이 있기 때문에 단순 텍스트를 전송하는 것보다 훨씬 더 효율적으로 데이터를 전송할 수 있습니다.  
이것은 사실 HTTP/2의 버전이 HTTP/1.2가 아닌 이유이기도 한데, 예전처럼 텍스트 기반의 전송이 아닌 바이너리 프레이밍을 사용하기 때문이다.  
![image](https://github.com/NoRuTnT/practice/assets/114069644/1841be34-a3e2-410f-9c72-49a0320ee628)  
두번째로 HTTP/2는 **응답 다중화(multiplexing)**를 지원한다. HTTP/1.1에서는 TCP연결에서 한번에 하나의 요청만 처리가능하며 요청별 순서를 반드시 지켜야 했던 것과는 대조적이다.  
HTTP/2에서는 하나의 TCP연결에서 여러요청을 동시에 처리할 수 있는데 이것은 TCP 연결을 스트림,메세지,프레임이라는 단위로 세분화했기때문이다.  
> - 스트림 : 요청과 응답이 양방향으로 오가는 논리적 연결 단위, TCP연결에서 여러개의 스트림이 동시에 존재할수있다.
> - 메세지 : 하나의 요청과 응답을 구성하는 단위
> - 프레임: 메세지를 구성하는 최소단위, 잘게쪼개어 전송되기때문에 수신측에서 다시 조립하여 사용

![image](https://github.com/NoRuTnT/practice/assets/114069644/2484df33-81d3-4608-b043-3d9aae8ac576)
위의 사진에는 하나의 TCP 연결 내에 3개의 스트림이 있는 것을 볼 수 있다. 그중 5번 스트림은 클라이언트측에서 서버로 데이터를 전송 중이며, 1, 3번 스트림은 서버 측에서 클라이언트로 데이터를 전송 중이다.  
또한 3번 스트림의 프레임이 1번 프레임 사이에 끼어들어 있는 것을 볼 수 있습. 클라이언트 측에서는 이것을 다 시 조립하여 사용한다.  
이러한 응답 다중화 기능 덕분에 HTTP/1.1에서 발생한 HOLB 문제를 해결할 수 있었다.  

