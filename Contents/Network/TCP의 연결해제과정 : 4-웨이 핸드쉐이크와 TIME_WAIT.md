## 4-Way Handshake

3-way handshake가 연결확립을 위해 진행했다면 4-way handshake는 세션을 종료하기 위해 수행하는 절차를 말한다.

- 연결 종료는 양쪽 호스트 모두 먼저 시도할 수 있다.
  
- 편의를 의해 양쪽 Host를 각각 클라이언트, 서버라고 부르고 설명한다.
  
  - 연결을 먼저 요청하는 Host -> 클라이언트
    
  - 연결을 요청받는 Host -> 서버
    
- 실제로 TCP는 양뱡향 통신이기에 '클라이언트-클라이언트'의 형태가 존재한다.
  

![](https://i.postimg.cc/cHCDbBPY/TCPHeader.png)

### 4-Way HandShake 과정

<p align="center"><img src="https://i.postimg.cc/hPDM275c/img1-daumcdn.png"></p>

- **ESTAB** : 포트가 연결된 상태
- **CLOSE-WAIT** : 상대방의 FIN(종료 요청)을 받은 상태
  - 상대방 FIN에 대한 ACK를 보내고 애플리케이션에 종료를 알린다.
- **LAST-ACK** : CLOSE-WAIT 상태를 처리 후 자신의 FIN요청을 보낸 후 FIN에 대한 ACK를 기다리는 상태
- **FIN-WAIT-1** : 자신이 보낸 FIN에 대한 ACK를 기다리거나 상대방의 FIN을 기다린다.
- **FIN-WAIT-2** : 자신이 보낸 FIN에 대한 ACK를 받았고 상대방의 FIN을 기다린다.
- **CLOSING** : 상대방의 FIN에 ACK를 보냈지만 자신의 FIN에 대한 ACK를 못받은 상태
- **TIME-WAIT** : 모든 FIN에 대한 ACK를 받고 연결 종료가 완료된 상태
  - 새 연결과 겹치지 않도록 일정 시간 동안 기다린 후 CLOSED로 전이한다.
- **CLOSED** : 연결 수립을 시작하기 전의 기본 상태 (연결 없음)

#### STEP 1 : 클라이언트 ---(FIN)---> 서버

- 클라이언트가 서버에게 연결 종료를 요청하는 FIN 세그먼트를 보낸다.
  
  - 세그먼트 헤더 내에 FIN 비트를 1로 설정한다.
    
- 이때 FIN 패킷에는 실질적으로 ACK도 포함되어 있다.
  
- 클라이언트는 전송 후 FIN-WAIT-1 상태가 된다.
  

> **HALF-CLOSE 기법**
> 
> 처음 보내는 종료 요청인 FIN 패킷에 실질적으로 ACK가 포함되어 있는 이유는 HALF-CLOSE 기법을 사용하기 때문이다.
> 
> - 연결을 종료하려고 할 때 완전히 종료하지 않고 반만 종료한다.
>   
> - HALF-CLOSE 기법을 사용하면 종료 요청자가 처음 보내는 FIN 패킷에 ACK를 함께 담아서 보낸다.
>   
>   - 이때 ACK는 "일단 연결은 종료할건데 귀는 열어둘게. 이 승인 번호(ACK)까지 처리했으니까 더 보낼 거 있으면 보내"를 의미한다.
>     
> - 이후 수신자가 남은 데이터를 모두 보내고 나면 다시 요청자에게 FIN패킷을 보냄으로써 모든 데이터가 처리되었다는 것을 알린다.
>   
> - 요청자는 나머지 반을 닫으면서 더 안전하게 연결을 종료할 수 있다.
>   

#### STEP 2 : 클라이언트 <---(ACK)--- 서버

- 서버는 FIN을 받고, 확인했다는 **ACK를 클라이언트에게 보내**고 자신의 통신이 끝날때까지 기다린다.
  
- 아직 남은 데이터가 있다면 마저 **전송을 마친 후에 close( )?를 호출**한다.
  
- **클라이언트**는 ACK를 받은 후에 **서버**가 남은 데이터 처리를 끝내고 **FIN 패킷을 보낼 때까지 기다린다**. (**FIN_WAIT_2)**
  

#### STEP 3 : 클라이언트 <---(FIN)--- 서버

- 서버가 데이터를 모두 보냈다면, 연결 종료에 합의한다는 의미로 FIN 패킷을 클라이언트에게 보낸다.
  
- 이후 ACK를 받을 때까지 기다리는 LAST_ACK 상태가 된다.
  

#### STEP 4 : 클라이언트 ---(ACK)---> 서버

- **클라이언트**는 FIN을 받고, 응답 ACK를 서버에게 보낸다.
  
- 아직 **서버**로부터 받지 못한 데이터가 있을 수 있으므로 **TIME_WAIT을 통해 기다린다.**
  
  - **TIME_WAIT** 상태는 의도치 않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지한다.
    

#### AFTER

- **서버**는 ACK를 받은 이후 소켓을 닫는다 (**Closed**)
  
- TIME_WAIT 시간이 끝나면 **클라이언트**도 소켓을 닫는다 (**Closed**)
  

#### 특징

- 클라이언트가 데이터 전송을 마쳤다고 하더라도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 FIN 메세지를 보낸다.
  
- 즉, 서버는 마지막 FIN을 보내기 전에 아직 전송하지 못한 데이터를 전송할 수 있다.
  
- 그러나, 데이터가 유실되어 재전송하거나, 지연되어 FIN 보다 늦게 도착할 수 있다.
  
- 따라서, 클라이언트는 FIN을 받고도 TIME_WAIT를 통해 혹시 모를 패킷 수신을 기다린다.
  

**심화학습자료**

[CLOSE_WAIT &#038; TIME_WAIT 최종 분석 &#8211; tech.kakao.com](https://tech.kakao.com/2016/04/21/closewait-timewait/)
