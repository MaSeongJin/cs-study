---
# 1. 네트워크 애플리케이션과 그 구조: Client-Server / P2P
---

## 네트워크 프로토콜
- 1 ~ 3계층은 하드웨어 적인 면이, 4 ~ 7계층은 소프트웨어 적인 면이 강조된다.
  
<img src="https://camo.githubusercontent.com/155051980ae01d4d6c621e4edc97eca23597ff079169f3b16b015c826d4e0117/68747470733a2f2f692e706f7374696d672e63632f7358574a57725a502f696d6167652e706e67"/>

## Client-server architecture
- 서버와 클라이언트 간 통신
- 클라이언트는 서버에게 요청(request)을 보내고, 응답(response)를 대기
- 서버는 24시간 대기하며, 요청을 받았을 때 해당하는 결과 응답을 보내줌, 서버의 주소는 고정되어야함(고정IP 사용)
- 구글, 아마존 등
<br/>

## P2P(Peer-To-Peer) architecture
- 서버에 의존하지 않고 호스트(Peer)끼리 직접 통신
- 각각이 서버와 클라이언트가 둘다 될 수 있어서, 데이터를 주고 받음
- 토렌트, 스카이프 등
<br/>

## 프로세스 간 통신이 이루어지는 네트워크 프로토콜
- 종단 시스템* 에서 실행하는 프로그램이 서로 통신할 때, 운영체제 용어로는 프로그램 대신에 '프로세스'라는 용어를 사용
- 프로세스 간의 통신을 위한 규칙은 종단 시스템의 운영체제를 따름
- 종단 시스템과 운영체제가 다르더라도 각 프로세스는 네트워크를 통한 메세지 교환으로 서로 통신할 수 있음

```
종단 시스템
: 호스트(호스트 = 클라이언트와 서버)
: 개방형 시스템 간 상호 접속(OSI)에서 규정한 모든 계층(7계층)을 갖춘 시스템. 
: 즉,네트워크에서 서로 통신하는 송신 시스템과 수신 시스템을 말하며,
  보통 LAN에서는 station(국), WAN에서는 host(주 컴퓨터)라 지칭.
```
<br/>

## 클라이언트 프로세스와 서버 프로세스
- 네트워크 애플리케이션은 네트워크에서 서로 메시지를 보내는 두 프로세스로 구성됨
- ex. 웹 애플리케이션에서 '클라이언트 프로세스(브라우저)'는 '웹 서버 프로세스'와 메시지를 교환
- ex. P2P 파일 공유 시스템에서는 한 피어의 프로세스(서버)에서 다른 피어의 프로세스(클라이언트)로 파일을 전송함
- 통신하는 프로세스 각 쌍에 대해 일반적으로 클라이언트의 프로세스와 서버의 프로세스 중 하나로 명명
<br/>


---
# 2. 애플리케이션 계층(Application Layer)이란?
---

## 네트워크 애플리케이션 계층
- 애플리케이션 계층은 네트워크 프로토콜 중 유저와 가장 가까운 계층
- 웹, 이메일, 파일 공유 등 사용자가 실제로 사용하는 것들을 체감할 수 있는 서비스를 제공하는 계층
- 사용자는 애플리케이션 계층의 네트워크 프로토콜이 존재하기에 서비스 내에서 통신할 수 있음
- HTTP, SMTP, FTP, SSH, DNS 등이 존재
<br/>

## OCI의 애플리케이션 계층을 통한 애플리케이션 계층에 대한 이해
- TCP/IP 방식은 OCI 방식에 비해 간단하지만 애플리케이션 계층의 구현은 개발자의 몫
- OCI 방식을 통해 애플리케이션 계층을 세분화하여 봄으로써 애플리케이션 계층에 대한 이해를 높일 수 있음

#### 응용계층(Lv7)
- 사용자가 실제로 사용하는 프로토콜
- 모든 통신의 종점, 응용 프로세스를 직접 수행하는 계층


#### 표현계층(Lv6)
- 데이터 표현이 상이한 응용 프로세스의 표현 방식을 일치하도록 변환
- 인코딩과 디코딩, 컴프레션과 디컴프레션
- JPEG와 GIF의 파일 확장자의 구분, EBCDIC로 인코딩된 문서를 ASCII로 인코딩된 문서로 변경하는 것은 표현 계층에서 수행


#### 세션계층(LV5)
- 애플리케이션에서 실질적으로 사용하는 통신 종단
- 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공
- 애플리케이션 계층과 전송 계층의 논리적 연결과 유효성 검사를 시행
- 운영체제가 세션 연결, 중단, 재연결 등을 수행하는 데에 실질적 역할을 하는 계층
- 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex) 의 통신 방식 존재

```
세션
: 세션이란 일정 시간동안 같은 사용자(브라우저)로 부터 들어오는
  일련의 요구를 하나의 상태로 보고 그 상태를 서버에 저장하여 일정하게 유지시키는 기술
```
<br/>


---
# 3. 소켓: 애플리케이션 계층과 전송 계층의 연결고리
---

## 소켓
- 프로세스와 컴퓨터 네트워크 사이의 인터페이스
- 애플리케이션 계층과 전송 계층 사이의 연결 고리
- 대부분의 애플리케이션은 통신 프로세스 쌍 (각 프로세스는 다른 프로세스에게 통신을 보낼 수도 받을 수도 있음)으로 구성되고, 이때 메시지는 네트워크를 통해 진행되는데 프로세스는 이때 소켓을 통해 네트워크로 메시지를 수신하고 송신
- 프로세스는 프로그램으로, 소켓은 프로그램의 출입구로 이해 가능

<p align="center">
 <img src="https://velog.velcdn.com/images%2Fjeanbaek%2Fpost%2F25f9d3a2-9b3a-4864-ba9b-b4dc35a84ef7%2Fimage.png"/>
</p>

- 두 프로세스 사이의 소켓 통신을 보여주는 그림
- 프로세스가 사용하는 하위 전송 프로토콜(규약)은 TCP 프로토콜로 가정
- 소켓은 호스트의 애플리케이션 계층과 전송 계층 간의 인터페이스
- 애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만, 소켓의 전송 계층에 대한 통제권은 약함
- 소켓의 전송 계층에 대한 통제는 전송 프로토콜의 선택과 최대 세그먼트 크기와 같은 전송 계층 매개변수의 설정 뿐


<p align="center">
 <img src="https://blog.kakaocdn.net/dn/c99qWT/btq2nppPVVh/XfDqEjrvAig0NePoXWK800/img.png"/>
</p>

### 참고) 소켓의 통신 과정

* 서버 측
1. 수신 소캣을 생성한다. (socket)
2. ip주소와 포트번호를 결정하여 소캣에 적용시킨다. (bind)
3. 클라이언트 요청을 대기하는 상태(listen 상태)로 변경한다. (listen)
4. 서버에 접속한 클라이언트와 통신할 수 있는 새로운 소캣을 생성한다. (accept)
5. 데이터 송수신을 한다. (recv, send)
6. 끝. (close)
<br>

* 클라이언트 측
1. 송신 소캣을 생성한다. (socket)
2. 서버에 접속한다. (connect)
3. 데이터를 송수신한다. (recv, send)
4. 끝 (close)
<br/>


---
# 4. HTTP, SSH, FTP, SMTP, DNS
---
HTTP
World Wide Web을 위한 데이터 통신의 기초이자 웹 사이트를 이용하는 데 쓰는 프로토콜

SSH
보안되지 않은 네트워크에서 네트워크 서비스를 안전하게 운영하기 위한 암호화 네트워크 프로토콜

FTP
장치와 장치 간의 파일을 전송하는 데 사용되는 표준 통신 프로토콜

SMTP
전자 메일 전송을 위한 인터넷 표준 통신 프로토콜

DNS
도메인 이름과 IP 주소를 매핑해주는 서버, DNS를 통해 IP 주소가 바뀌어도 사용자들에게 똑같은 도메인 주소로 서비스할 수 있음
가령, ```www.naver.com```의 IP 주소가 222.111.222.111에서 222.111.222.122로 바뀌더라도 DNS를 통해 똑같은 ```www.naver.com```이라는 주소로 서비스 재공 가능



---
# 4. HTTP vs HTTPS
---
HTTP & HTTPS

#HTTP(HyperText Transfer Protocol)
인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약


HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다.

이런 보안 문제를 해결해주는 프로토콜이 'HTTPS'


#HTTPS(HyperText Transfer Protocol Secure)
인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

HTTPS는 텍스트를 암호화한다. (공개키 암호화 방식으로)

공개키 설명(opens new window)


#HTTPS 통신 흐름
애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.

신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하며 계약을 한다.

CA란? : Certificate Authority로, 공개키를 저장해주는 신뢰성이 검증된 민간기업

계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.

A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.

클라이언트가 main.html 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다.

CA 기업의 공개키는 브라우저가 이미 알고있다. (세계적으로 신뢰할 수 있는 기업으로 등록되어 있기 때문에, 브라우저가 인증서를 탐색하여 해독이 가능한 것)

브라우저는 해독한 뒤 A서버의 공개키를 얻게 되었다.

클라이언트가 A서버와 HandShaking 과정에서 주고받은 난수를 조합하여 pre-master-key(대칭키) 를 생성한 뒤, A서버의 공개키로 해당 대칭키를 암호화하여 서버로 보냅니다.

A서버는 암호화된 대칭키를 자신의 개인키로 복호화 하여 클라이언트와 동일한 대칭키를 획득합니다.

이후 클라이언트-서버사이의 통신을 할 때 주고받는 메세지는 이 pre-master-key(대칭키)를 이용하여 암호화, 복호화를 진행합니다.


HTTPS도 무조건 안전한 것은 아니다. (신뢰받는 CA 기업이 아닌 자체 인증서 발급한 경우 등)

이때는 HTTPS지만 브라우저에서 주의 요함, 안전하지 않은 사이트와 같은 알림으로 주의 받게 된다.

