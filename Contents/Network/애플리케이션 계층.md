---
# 1. 네트워크 애플리케이션과 그 구조: Client-Server / P2P
---

## 네트워크 프로토콜
- 1 ~ 3계층은 하드웨어 적인 면이, 4 ~ 7계층은 소프트웨어 적인 면이 강조된다.
  
<img src="https://camo.githubusercontent.com/155051980ae01d4d6c621e4edc97eca23597ff079169f3b16b015c826d4e0117/68747470733a2f2f692e706f7374696d672e63632f7358574a57725a502f696d6167652e706e67"/>

## Client-server architecture
- 서버와 클라이언트 간 통신
- 클라이언트는 서버에게 요청(request)을 보내고, 응답(response)를 대기
- 서버는 24시간 대기하며, 요청을 받았을 때 해당하는 결과 응답을 보내줌, 서버의 주소는 고정되어야함(고정IP 사용)
- 구글, 아마존 등
<br/>

## P2P(Peer-To-Peer) architecture
- 서버에 의존하지 않고 호스트(Peer)끼리 직접 통신
- 각각이 서버와 클라이언트가 둘다 될 수 있어서, 데이터를 주고 받음
- 토렌트, 스카이프 등
<br/>

## 프로세스 간 통신이 이루어지는 네트워크 프로토콜
- 종단 시스템* 에서 실행하는 프로그램이 서로 통신할 때, 운영체제 용어로는 프로그램 대신에 '프로세스'라는 용어를 사용
- 프로세스 간의 통신을 위한 규칙은 종단 시스템의 운영체제를 따름
- 종단 시스템과 운영체제가 다르더라도 각 프로세스는 네트워크를 통한 메세지 교환으로 서로 통신할 수 있음

```
종단 시스템
: 호스트(호스트 = 클라이언트와 서버)
: 개방형 시스템 간 상호 접속(OSI)에서 규정한 모든 계층(7계층)을 갖춘 시스템. 
: 즉,네트워크에서 서로 통신하는 송신 시스템과 수신 시스템을 말하며,
  보통 LAN에서는 station(국), WAN에서는 host(주 컴퓨터)라 지칭.
```
<br/>

## 클라이언트 프로세스와 서버 프로세스
- 네트워크 애플리케이션은 네트워크에서 서로 메시지를 보내는 두 프로세스로 구성됨
- ex. 웹 애플리케이션에서 '클라이언트 프로세스(브라우저)'는 '웹 서버 프로세스'와 메시지를 교환
- ex. P2P 파일 공유 시스템에서는 한 피어의 프로세스(서버)에서 다른 피어의 프로세스(클라이언트)로 파일을 전송함
- 통신하는 프로세스 각 쌍에 대해 일반적으로 클라이언트의 프로세스와 서버의 프로세스 중 하나로 명명
<br/>


---
# 2. 애플리케이션 계층(Application Layer)이란?
---

## 네트워크 애플리케이션 계층
- 애플리케이션 계층은 네트워크 프로토콜 중 유저와 가장 가까운 계층
- 웹, 이메일, 파일 공유 등 사용자가 실제로 사용하는 것들을 체감할 수 있는 서비스를 제공하는 계층
- 사용자는 애플리케이션 계층의 네트워크 프로토콜이 존재하기에 서비스 내에서 통신할 수 있음
- HTTP, SMTP, FTP, SSH, DNS 등이 존재
<br/>

## OCI의 애플리케이션 계층을 통한 애플리케이션 계층에 대한 이해
- TCP/IP 방식은 OCI 방식에 비해 간단하지만 애플리케이션 계층의 구현은 개발자의 몫
- OCI 방식을 통해 애플리케이션 계층을 세분화하여 봄으로써 애플리케이션 계층에 대한 이해를 높일 수 있음

#### 응용계층(Lv7)
- 사용자가 실제로 사용하는 프로토콜
- 모든 통신의 종점, 응용 프로세스를 직접 수행하는 계층


#### 표현계층(Lv6)
- 데이터 표현이 상이한 응용 프로세스의 표현 방식을 일치하도록 변환
- 인코딩과 디코딩, 컴프레션과 디컴프레션
- JPEG와 GIF의 파일 확장자의 구분, EBCDIC로 인코딩된 문서를 ASCII로 인코딩된 문서로 변경하는 것은 표현 계층에서 수행


#### 세션계층(LV5)
- 애플리케이션에서 실질적으로 사용하는 통신 종단
- 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공
- 애플리케이션 계층과 전송 계층의 논리적 연결과 유효성 검사를 시행
- 운영체제가 세션 연결, 중단, 재연결 등을 수행하는 데에 실질적 역할을 하는 계층
- 
```
세션
: 세션이란 일정 시간동안 같은 사용자(브라우저)로 부터 들어오는
  일련의 요구를 하나의 상태로 보고 그 상태를 서버에 저장하여 일정하게 유지시키는 기술
```
<br/>


---
# 3. 소켓: 애플리케이션 계층과 전송 계층의 연결고리
---

## 소켓
- 프로세스와 컴퓨터 네트워크 사이의 인터페이스
- 애플리케이션 계층과 전송 계층 사이의 연결 고계로 동작하며 요청 및 응답 메세지로 대응됨
- 메세지 교환 형태의 프로토콜로, 클라이언트와 서버 간에 `HTTP 메세지`를 주고받으며 통신
- 무상태와 비연결성이라는 특징을 가짐(이를 해결하기 위해 쿠키와 세션이라는 개념 사용)


### 참고) HTTP 메세지의 구조
<p align="center">
 <img src="https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/06/HTTP_messages.png?w=1239&ssl=1"/>
</p>


### (1) HTTP 요청 메세지
<p align="center">
 <img src="http://www.ktword.co.kr/img_data/648_1.JPG"/>
</p>

- (1-1) Request line :: 요청방법(Method), 요청 URI, HTTP 버전 등을 나타냄
- (1-2) Header :: 이름:값의 형식으로 ```Host: www.kt.co.kr```,  ```User-Agent: Mozilla/4.0``` 와 같이 호스트 정보, 브라우저 정보 등을 나타냄
- (1-3) Blank line :: CRLF, (\r\n), 줄바꿈
- (1-4) Body :: GET일 경우 비어있으며, POST일 경우 채워짐

- HTTP 요청 메세지 예시
<p align="center">
 <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FceqzRL%2FbtrFHEJFUZb%2FMeb7vQf0y3oeB0ZU7xV8eK%2Fimg.png"/>
</p>
<br/>

### (2) HTTP 응답 메세지
<p align="center">
 <img src="http://www.ktword.co.kr/img_data/648_1.JPG"/>
</p>

- (2-1) Response line :: HTTP 상태 코드*
- (2-2) Header :: 이름:값의 형식으로 ```Server: Apache/1.3.0```와 같이 서버의 정보 등을 나타냄
- (2-3) Blank line :: CRLF, (\r\n), 줄바꿈
- (2-4) Body :: 요청에 따라 실제 전달할 내용

```
HTTP 상태 코드
: 1XX - 처리 중
: 2XX - 성공
: 3XX - 리다이렉션
: 4XX - 클라이언트 오류 (404: 요청 리소스 부재, 405: 해당 메소드 미허용 등)
: 5XX - 서버 오류 (500: 서버 내부 오류 등)
```

- HTTP 응답 메세지 예시
<p align="center">
 <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbhue8H%2FbtrFFB1OcZf%2F6PMLEI7rbXyaUQny5CRizk%2Fimg.png"/>
</p>
<br/>


## SSH (Secure Shell)
- 원격 호스트에 접속하기 위해 사용되는 보안 프로토콜
- 암호화되지 않은 telnet(원격 접속 프로그램) 등에 대한 패킷 스니핑 등의 보안공격 방지
- SSH 프로토콜은 인증, 기밀성 유지, 무결성, 압축, 포트 포워딩(터널링) 등 보안과 관련된 기능 수행
- 클라이언트-서버 관계로 동작, 사용자 클라이언트 및 응용 서버 사이에서 SSH 클라이언트 및 SSH 서버가 존재
- 설치된 두 S/W(SSH 클라이언트 및 SSH 서버) 사이에서 TCP 보안 채널이 형성(서버는 원격 접근하려는 호스트, 클라이언트는 원격 접근하는 사용자)
- SSH 상에서 사용되는 전송계층 프로토콜은 TCP만 가능(TCP 상에 보안 채널 형성)
- SSH 서버에 개방되는 포트 번호는 22번

<details>
<summary>대칭키와 비대칭키(공개키)의 개념과 SSH의 키</summary>
<div>

### SSH의 키
SSH를 구성하는 가장 핵심적인 키워드는 ‘KEY(키, 열쇠)’입니다. 사용자(클라이언트)와 서버(호스트)는 각각의 키를 보유하고 있으며, 이 키를 이용해 연결 상대를 인증하고 안전하게 데이터를 주고 받게 됩니다. 여기서 키를 생성하는 방식이 두 가지가 있는데, 그것이 SSH를 검색했을 때 가장 쉽게 볼 수 있는 ‘대칭키’와 ‘비대칭키(또는 공개 키)’ 방식입니다.

### 비대칭키 방식

작동하는 순서를 하나하나씩 짚어보도록 하겠습니다. 가장 먼저 사용자와 서버가 서로의 정체를 증명해야 합니다. 이 시점에서 사용되는 것이 비대칭키 방식입니다. 비대칭키 방식에서는 서버 또는 사용자가 Key Pair(키 페어, 키 쌍)를 생성합니다. 키 페어는 공개 키와 개인 키의 두 가지로 이루어진 한 쌍을 뜻하며, 보통 공개 키의 경우 .pub, 개인 키의 경우 .pem의 파일 형식을 띄고 있습니다.

예를 들어보겠습니다. 사용자가 키 페어를 생성했을 경우, 공개 키를 서버에 전송합니다. 공개 키는 말 그대로 ‘공개’된 키이기 때문에 누구나 가질 수 있습니다. 때문에 전송과정에서 유출되어도 크게 문제가 되지 않습니다. 서버는 공개 키를 받아서, 이 공개 키로 만들어진 랜덤한 값을 생성합니다. 이 값은 사용자가 올바른 키 페어를 가지고 있는지 시험하는 일종의 시험지와 같습니다.

시험지를 받은 사용자는 가지고 있는 개인 키를 이용해 이 시험지를 풉니다. 앞서 말씀드린 것처럼 공개 키와 개인 키는 하나의 커플 관계와도 같기 때문에, 다른 공개 키나 개인 키를 이용해서 풀어낼 수 없습니다. 오직 키 페어 생성 시 함께 생성된 개인 키와 공개 키만 서로 해석이 가능합니다. 다시 말해 개인 키를 제외한 그 어떤 방법으로도 이 시험지를 풀어낼 수 없습니다.

또한 개인 키는 공개 키와 달리 다른 어디에도 보여주지 않는 소중한 파일입니다. 그래서 결과적으로 개인 키가 서버와 사용자 간의 사이를 증명하는 수단이 되는 것입니다. 공개 키에서 나온 문제는 개인 키로만 풀 수 있고, 개인 키는 사용자만 가지고 있으니까요. 이후 시험지를 풀어서 나온 값을 사용자는 다시 서버에 전송합니다.

서버는 사용자로부터 전송받은 값을 자신이 처음에 낸 값과 비교합니다. 두 값이 같게 되면 서버는 “이 사용자는 내 공개 키에 대응하는 올바른 개인 키를 보유하고 있으니, 내가 아는 사용자가 맞다!” 라고 판단하고 접속을 허용해줍니다. 이렇게 최초 접속 시 사용자와 서버 간의 인증 절차가 비대칭키 방식을 통해 완료됩니다.

### 대칭키 방식

서로가 누군지를 알았으니 이제 정보를 주고받을 차례입니다. 주고받는 과정에서 정보가 새어나가지 않기 위해 정보를 암호화해서 주고받는데, 여기서 사용되는 과정이 대칭키 방식입니다. 대칭키 방식에서는 비대칭키 방식과 달리 한 개의 키만을 사용하는데, 우리는 이것을 대칭 키라고 합니다.

아까와 같은 예를 들어보겠습니다. 사용자 또는 서버는 하나의 대칭 키를 만들어 서로 공유합니다. 공유된 대칭 키를 이용해 정보를 암호화하면, 받은 쪽에서 동일한 대칭 키로 암호를 풀어 정보를 습득하게 됩니다. 정보 교환이 완료되면 교환 당시 썼던 대칭 키는 폐기되고, 나중에 다시 접속할 때마다 새로운 대칭 키를 생성하여 사용하게 됩니다.
</div>
</details>
<br/>


## FTP (File Transfer Protocol)
- 파일 전송을 위한 프로토콜로, 파일을 컴퓨터 간에 전송하는 데 사용
- 클라이언트-서버 관계를 이루며 동작
- 2개의 TCP 연결을 생성하며, 서로다른 용도로 사용
- 하나는 명령어의 전달용 : FTP-CONTROL, 다른 하나는 데이터의 전송용 : FTP-DATA

![image](https://github.com/jeonseongjae98/cs-study/assets/114549688/60d4f81a-4edb-4c34-a920-5275f7086d90)

```
반이중화 방식
: 양쪽 장치가 하나의 채널로 송수신하여 한 번에 송신이나 수신만 할 수 있는 방식

전이중화 방식
: 양쪽 장치가 동시에 송수신할 수 있는 방식, 송신로와 수신로 구분
```
<br/>

## SMTP (Simple Mail Transfer Protocol)
- 두 메일시스템이 전자우편을 교환할 수 있게 하는 메세지 전송용 프로토콜
- 클라이언트-서버 관계, 이메일 클라이언트에서 서버로 이메일을 보내는 데 사용
- 이메일 서버 간에 이메일을 라우팅하고 전달하는 역할
- TCP 연결에 기초하고 포트는 25번 사용

### 참고) SMTP의 서버와 클라이언트
- sender@gmail.com 유저가 receiver@naver.com에 메일을 전송할 경우 누가 클라이언트고 누가 서버일까?
<details>
<summary>정답 확인</summary>
<div>

두 유저는 모두 클라이언트!!!
gmail.com과 naver.com이 서버!!!
![image](https://github.com/jeonseongjae98/cs-study/assets/114549688/715a51ec-8e16-4348-a1d9-223628ea7f6d)

</div>
</details>
<br/>


## DNS (Domain Name System):
- 인터넷에서 도메인 이름과 IP 주소 간의 변환을 수행하는 프로토콜
- IP 주소 및 기타 데이터를 저장한 뒤 이름에 따라 쿼리할 수 있게 해주는 계층형 분산 데이터베이스
- 가령, 사용자가 브라우저에 웹 사이트 도메인 이름(URL)을 입력하면 DNS는 URL을 해당 이름과 연결된 웹 서버의 IP 주소로 변환하여 연결을 가능하게 함
- DNS를 통해 IP 주소가 바뀌어도 사용자들에게 똑같은 도메인 주소로 서비스 가능
- 가령, ```www.naver.com```의 IP 주소가 222.111.222.111에서 222.111.222.122로 바뀌더라도 DNS를 통해 똑같은 ```www.naver.com```이라는 주소로 서비스 재공 가능
- 인터넷상의 대규모 자원에 대한 명칭부여와 분산화,  루트 노드로부터 `최대 128개 레벨`을 갖는 역 계층구조
- 하나의 영문이름에 여러 개의 IP 주소를 집합시켜 트래픽의 부하분산 효과 가능

#### DNS 희망편
![image](https://github.com/jeonseongjae98/cs-study/assets/114549688/0537e507-1a56-474d-86d5-972c0a818848)

#### DNS 절망편
- DNS가 계층구조를 갖는다는 의미
- DNS의 개수가 많기 때문에 DNS의 서버 종류를 계층화해서 단계적으로 처리하고자 DNS는 최상위 도메인에서부터 서브 도메인까지 계층 형태로 구성
![image](https://github.com/jeonseongjae98/cs-study/assets/114549688/f717ffa0-0eff-4624-b65c-307136965d9f)

(1) Root DNS Server
- ICANN이 직접 관리하는 최상위 서버로, TLD DNS 서버 IP들을 저장해두고 안내하는 역할 수행

(2) TLD DNS Server
- 도메인 등록 기관(Registry)이 관리하는 서버로, Authoritative DNS 서버 주소를 저장해두고 안내하는 역할 수행

(3) Authoritative DNS Server
- 실제 개인 도메인과 IP 주소의 관계가 기록/저장/변경되는 서버
- 일반적으로 도메인/호스팅 업체의 ‘네임서버’를 지칭

(4) Recursive DNS Server
- 인터넷 사용자가 가장 먼저 접근하는 DNS 서버(실제 브라우저가 활용하는 서버)
- 접속할 때마다 상위 3개의 DNS 서버를 매번 거친다면 효율이 좋지 않므으로 한 번 거친 후 얻은 데이터를 일정 기간(TTL/Time to Live) 동안 캐시라는 형태로 저장해 두는 서버
- 직접 도메인과 IP 주소의 관계를 기록/저장/변경하지는 않고 캐시만을 보관하기 때문에, Authoritative(권한을 가진)와 비교되는 의미로 반복의 Recursive(반복되는)가 붙음. - 대표적으로 KT/LG/SK와 같은 ISP(통신사) DNS 서버가 있고, 브라우저 우회 용도로 많이 쓰는 구글 DNS, 클라우드플레어와 같은 Public DNS 서버가 존재


---
## 문제 1. TCP/IP 프로토콜에서 TCP가 해당하는 계층은?
① 데이터 링크 계층 <br/>
② 네트워크 계층 <br/>
③ 트랜스포트 계층 <br/>
④ 세션 계층 <br/>
<br/>

## 문제 2. TCP/IP 프로토콜 중 계층이 다른 프로토콜은?
① HTTP <br/>
② SMTP <br/>
③ TCP <br/>
④ FTP <br/>
<br/>

## 문제 3. HTTP 상태코드에 대한 설명으로 올바른 것은?
① 100번대 : 성공, 메소드 지시대로 요청을 성공적으로 수행 <br/>
② 200번대 : 정보 제공, 요청 계속 혹은 사용 프로토콜 변경 지시 <br/>
③ 300번대 : 리다이렉션, 요청 수행 완료를 위해 추가적인 작업 필요 <br/>
④ 400번대 : 서버 에러, 클라이언트 요청은 유효하나 서버 자체의 문제 발 <br/>
<br/>

## 문제 4. DNS에서 사용될 때 TTL의 설명으로 올바른 것은?
① 데이터가 DNS 서버 존으로부터 나오기 전에 현재 남은 시간이다. <br/>
② 데이터가 DNS 서버 캐시로부터 나오기 전에 현재 남은 시간이다. <br/>
③ 패킷이 DNS 서버 존으로부터 나오기 전에 현재 남은 시간이다. <br/>
④ 패킷이 DNS 서버 네임서버 레코드로부터 나오기 전에 현재 남은 시간이다. <br/>
<br/>

<details>
<summary>정답</summary>
<div>

3, 3, 3, 2

</div>
</details>
