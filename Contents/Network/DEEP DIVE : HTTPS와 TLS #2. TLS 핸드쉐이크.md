# 들어가기 전에 복기하면 좋을 개념
- 전송 계층의 두 가지 역할 </br>
    ① 데이터가 제대로 도착했는지 확인</br>
    ② 전송된 데이터의 목적지가 어떤 애플리케이션인지 식별


## TLS(Transport Layer Security)란?
- 전송 계층 보안(영어: Transport Layer Security, TLS, 과거 명칭: 보안 소켓 레이어/Secure Sockets Layer, SSL)는 컴퓨터 네트워크에 통신 보안을 제공하기 위해 설계된 암호 규약이다.
- 인터넷 상의 커뮤니케이션에서 개인 정보와 데이터 보안을 위해 설계되어 널리 채택된 보안 프로토콜이다.
- 주요 사용 사례는 웹 브라우저(웹 응용 프로그램)와 서버 간의 통신 데이터를 암호화하는 것이다. 그 외에도 이메일, 메시지, 보이스오버 IP(VoIP)등 여러 통신 데이터를 암호화한다.
- TLS는 Netscape가 개발한 SSL(Secure Sockets Layer)이라는 이전의 암호화 프로토콜에서 발전한 것이다.
- HTTPS는 HTTP 프로토콜 상위에서 TLS 암호화를 구현한 것이다. HTTPS를 사용하는 웹 사이트는 TLS 암호화를 사용한다.
- TLS : 4계층 Transport Layer이고, TCP 443 포트를 사용한다.
-TLS는 응용 계층과 전송 계층 사이에서 응용 계층 데이터의 암/복호화를 책임진다.

## TLS가 하는 것?
- 암호화 : 제3자로부터 전송되는 데이터를 숨긴다.
- 인증 : 정보를 교환하는 당사자가 요청된 당사자임을 보장한다.
- 무결성 : 데이터가 위조되거나 변조되지 않았는지 확인한다.

## TLS Handshake
- TLS는 안전한 인터넷 통신을 위한 암호화 및 인증 프로토콜입니다.
- TLS 핸드셰이크는 TLS 암호화를 사용하는 통신 세션을 실행하는 프로세스입니다. TLS 핸드셰이크 중에, 통신하는 양측에서는 메시지를 교환하여 서로를 인식하고 서로를 검증하며 사용할 암호화 알고리즘을 구성하고 세션 키에 합의합니다. TLS 핸드셰이크는 HTTPS 작동 원리의 근간을 이룹니다.
- TLS 연결은 TLS Handshake를 사용한다. 사용자가 TLS를 사용하는 웹사이트를 접속하면 클라이언트와 웹 서버간에 TLS Handshake가 시작된다.
- 클라이언트는 서버의 인증서를 받아 서버의 무결성을 확인하고 신뢰할 수 있는 서버라면, 암호화 통신에 사용할 대칭키를 서버의 공개키로 암호화 하여 전달한다.
- 여기서 데이터를 주고 받기 전, 서버의 무결성을 확인하고 대칭키를 전달하는 과정 → **TLS Handshake**

 

### TLS Handshake를 하는 동안 클라이언트와 웹 서버는 아래 일을 수행한다.
- 사용할 TLS 버전 지정
- 사용할 암호 제품군 결정 - 공유된 암호화 키 또는 세션 키와 같은 세부 정보를 명시하는 알고리즘 집합
- 서버의 TLS 인증서를 사용하여 서버의 신원을 인증
- Handshake가 완료된 후 메시지를 암호화하기 위한 세션 키 생성
    - 공개키 암호화 방식을 사용하여 TLS는 세션 키를 설정할 수 있다.
        → 클라이언트는 생성된 대칭키를 서버의 공개키로 암호화한다
    - Handshake는 인증도 처리하는데 이는 공개 키를 사용하여 수행된다.

- 📖 공개키는 단방향 암호화를 사용하는 암호화 키로, 공개 키를 가진 누구나 신뢰성을 보장하기 위해 서버의 개인 키로 암호화된 데이터를 해독할 수 있음을 의미하지만 원래 발신자만 개인 키를 이용해 데이터를 암호화할 수 있다.
- 서버의 공개키는 TLS 인증서의 일부이다.
- 데이터 암호화와 인증이 진행되면 메시지 인증 코드(MAC)와 함께 서명된다. 수신자는 데이터의 무결성을 보장하기 위해 MAC을 확인할 수 있다.

[![1.png](https://i.postimg.cc/tJRJN0g7/1.png)](https://postimg.cc/cgjddbwN)

# TLS Handshake 진행 과정


## 1. Client : Client Hello
- 클라이언트가 서버에서 Client Hello 메시지 전송
패킷 내에는 TLS Version, Client가 지원하는 암호화 방식, Client Random Data(클라이언트에서 생성한 난수로 대칭키를 만들 때 사용), Session ID, SNI(서버명) 가 포함된다.

- Session ID
: 매번 연결할 때마다 Handshake 과정을 진행하는 것은 비효율적이니 최초 한번 전체 Handshake 과정을 진행하고 Session ID를 가진다. 후에는 이 Session ID를 사용해서 위 과정을 반복해서 진행하지 않는다.


- 최초 Handshake에선 SessionID가 0이지만 Handshake를 한번 진행하면 서버로부터 Session ID를 받는다.
- 클라이언트는 로컬에 저장해두고 다시 서버와 Handshake과정을 맺을 일이 있다면 Session ID를 포함한 패킷을 전송한다.
- 서버에서는 전달받은 Session ID가 아직 유효하다면 동일한 Session ID를 다시 전송한다.
- 이 과정에서 최초 Handshake를 위해 진행한 작업들을 하지 않기 때문에 시간이 절약된다.

## 2. Server Hello, Server Certificate, Server Hello Done
- Server : Server Hello
- 클라이언트가 보낸 Client Hello에 대한 서버의 응답이다. TLS Version, 암호화 방식(Client가 보낸 암호화 방식 중에 서버가 사용 가능한 암호화 방식을 선택), Server Random Data(서버에서 생성한 난수, 대칭키를 만들 때 사용), SessionID(유효한 Session ID)

- Server : Server Certificate
- 서버의 인증서를 클라이언트에게 보내는 단계로 필요에 따라 CA의 Certificate도 함께 전송한다.
    - 클라이언트는 이 패킷을 통해 서버의 인증서가 무결한지 검증한다.

 - Server :  Server Hello Done
서버가 클라이언트에게 보낼 메시지를 모두 보냈다는 뜻

## Client Key Exchange, Change Cipher Spec, Finished
- Client : **Client Key Exchange**
인증서가 무결한지 검증 되었으면 클라이언트의 난수와 서버의 난수를 조합하여 대칭키를 생성한다.
- 그리고 대칭키를 서버의 공개키로 암호화한다.
- 암호화한 정보를 서버에게 전송한다.
- 정리를 하자면, 키 교환에 필요한 정보를 서버에 제공한다. 이 정보를 pre-master secret이라고 하며 대칭키에 사용되는 것으로 절대 노출이 되어서는 안된다. pre-master secret은 난수를 조합하여 생성한 것이다.
- 이 값을 서버의 공개키로 암호화해서 전송하면 서버는 개인키로 복호화가 가능하다. 그렇게 되면 서로가 pre-master secret을 공유하게 된다. 이 값을 사용해서 세션에 사용될 키를 생성하게 되는데, 이 키가 바로 대칭키이다.
- **Server & Client** : Change Cipher Spec
이제부터 전송되는 모든 패킷은 협상된 알고리즘과 키를 이용하여 암호화 하겠다고 알리는 메시지
- **Server & Client** : Finished
TLS Handshake를 성공적으로 마치고 종료

# Session keys and TLS handshakes
- TLS 프로토콜은 비대칭/공개 키와 대칭 암호화를 모두 사용하며, 각 통신 세션에 대해 대칭 암호화를 위한 새로운 키를 생성해야 한다. 이러한 키를 **"세션 키"** 라고 한다.

## 세션 키란 무엇인가?
- 세션 키는 TLS 핸드셰이크가 완료된 후에 TLS를 통한 통신 양측에서 사용하는 대칭 키이다.
- 양측이 세션 키에 대해 합의하고 나면 더 이상 공개키와 개인키를 사용할 필요가 없으며, TLS는 각각의 고유 세션에 대해 서로 다른 세션 키를 생성한다.
- 세션 키는 하나의 통신 세션을 암호화하는 데 사용되는 대칭 암호화 키이다. 다시 말해, 두 당사자 간에 전송되는 데이터를 암호화하고 해독하는 데 한 번만 사용되는(한 세션 타임이 끝날 때까지) 임시 키이다. 두 당사자 간의 이후 대화는 서로 다른 세션 키로 암호화된다. 세션 키는 사용자가 로그인할 때마다 재설정되는 암호와 같다.
- TLS에서, 두 통신 당사자(클라이언트 및 서버)는 TLS 핸드셰이크가 진행되는 동안 통신 세션을 시작할 때 세션 키를 생성한다. TLS에 대한 공식 RFC는 실제로 이러한 키를 "세션 키"라고 부르지는 않지만 기능적으로는 세션 키와 같다.

## 세션이란 무엇인가?
- 세션은 본질적으로 두 당사자 사이의 단일 대화이다. 세션은 네트워크를 통해 이루어지며 두 장치가 서로를 인식하고 가상 연결을 열 때 시작됩니다. 두 기기가 서로 필요한 정보를 입수해(통신을 완료하고) '닫기_알림' 메시지를 보내면서 마치 두 사람이 문자를 주고받는 것처럼 연결을 종료하고 "나중에 통화하자"고 말하며 대화를 닫는다. 두 사람이 문자 메시지를 보내고 단순히 서로에게 응답하지 않는 것과 같이 비활성으로 인해 연결이 시간 초과될 수도 있다.

[![1.png](https://i.postimg.cc/hGKTnf5y/1.png)](https://postimg.cc/jDkLQdKP)

- 세션은 설정된 기간일 수도 있고, 두 당사자가 통신하는 동안 지속될 수도 있다. TLS 암호화의 맥락에서 두 장치는 정보를 교환하고 새 세션 키를 생성하여 연결을 다시 열어야 한다.


## 암호화 키(Cryptographic key)란 무엇인가?
- 암호화에서는 암호화 알고리즘의 특수 입력을 참조하기 위해 키(일반적으로 짧은 데이터 조각)에 대해 이야기하는 것이 일반적이다. 가장 일반적인 키는 데이터 암호화에 사용되는 키이다. 그러나 다른 목적을 위해 다른 유형의 키가 존재한다.
- 데이터 암호화 알고리즘은 (비밀) 키를 사용하여 메시지를 암호문, 즉 스크램블되어 읽을 수 없는 메시지 버전으로 변환합니다. 암호 해독 키를 사용하여 암호문에서 원본 메시지를 복구할 수 있다.
- 대칭 암호화 알고리즘에서는 암호화 키와 암호 해독 키가 모두 동일합니다. 따라서 비밀 키를 보유한 사람은 누구나 데이터를 암호화 및 해독할 수 있으며 이것이 대칭 키라는 용어가 자주 사용되는 이유이다.
- 반대로, 공개 키 암호화라고도 하는 비대칭 암호화 알고리즘에는 두 개의 키가 있다. 하나는 공개이고 데이터 암호화에만 사용할 수 있는 반면 다른 하나는 비공개로 유지되어 암호문 해독에만 사용된다.


### 참고)  비대칭 암호화(공개키 암호화)
대칭키 암호는 송신자와 수신자가 하나의 키를 공유해서 사용한다.
이러한 대칭키에는 두 가지 문제점이 있다.

1) 최초에 비밀키를 안전하게 주고 받는 것이 어렵다.
2) 너무 많은 키가 필요하다. (n명이 통신 할 경우 n(n-1)/2 개의 키 필요)

이를 해결하기 위해 비대칭 암호화(=공개키 암호화) 방식을 사용한다.

** 비대칭 암호화(asymmetric cryptography) = 공개키 암호화 방식
[![1.png](https://i.postimg.cc/5y5QDJmd/1.png)](https://postimg.cc/BP6v1dyM)


- 비대칭 암호화 방식은 public key로 암호화를 하고 받는 쪽에서 private key로 복호화를 하는 방식이다.
- 대칭 암호화 방식은 많은 키가 필요하지만 비대칭 암호화 방식은 공개키와 비밀키만 관리하면 된다.
- 즉, Bob이 Alice에게 메시지를 보낼때 Alice의 public key로 암호화를 하면 Alice는 본인의 Private key로 복호화를 한다.

 

#### 비대칭 암호화 방식의 단점
- 대칭키 암호화에 비해 속도가 느리다. 
    - 그래서 비대칭 암호화(공개키 암호화)는 주로 대칭키 암호 통신을 위한 키쌍을 만들 때 사용한다.
- 즉! 통신은 대칭키 암호화로 빠르게 하지만, 키를 처음에 교환할 때 공개키 암호를 사용하는 것이다.
    - 이 때 만들어지는 대칭키의 쌍을 세션키(Session key)라고 한다.


# 📖요약
## TLS 핸드셰이크가 이루어지는 단계는 어떻게 될까요?
[![1.png](https://i.postimg.cc/fRS4j0p3/1.png)](https://postimg.cc/CR06wdFY)
- TLS 핸드셰이크의 정확한 단계는 사용되는 키 교환 알고리즘의 유형과 커뮤니케이션 양측에서 모두 지원하는 암호 제품군의 유형에 따라 달라진다.

1. Client Hello: 클라이언트가 서버로 Hello 메시지를 전송하면서 핸드셰이크를 개시합니다. 이 메시지에는 클라이언트가 지원하는 TLS 버전, 지원되는 암호 제품군, 그리고 클라이언트 무작위라고 하는 무작위 바이트 문자열이 포함된다.
2. Server Hello: Client Hello 메시지에 대한 응답으로 서버가 서버의 TLS(SSL) 인증서, 서버에서 선택한 암호 제품군, 그리고 서버에서 생성한 또 다른 무작위 바이트 문자열인 서버 무작위를 포함하는 메시지를 전송한다.
3. 인증: 클라이언트가 서버의 SSL 인증서를 인증서 발행 기관을 통해 검증합니다. 이를 통해 서버가 인증서에 명시된 서버가 맞는지 확인합니다.
4. 예비 마스터 암호: 클라이언트가 예비 마스터 암호라고 하는 무작위 바이트 문자열을 하나 더 전송합니다. 예비 마스터 암호는 공개 키로 암호화되어 있으며, 서버가 개인 키로만 해독할 수 있습니다.
5. 개인 키 사용: 서버가 예비 마스터 암호를 해독합니다.
6. 세션 키 생성: 클라이언트와 서버 모두 클라이언트의 무작위 값, 서버의 무작위 값, 예비 마스터 암호를 이용해 세션 키를 생성합니다. 모두 같은 결과가 나와야 합니다.
7. 클라이언트 준비 완료: 클라이언트가 세션 키로 암호화된 완료메시지를 전송합니다.
8. 서버 준비 완료: 서버가 세션 키로 암호화된 완료메시지를 전송합니다.
9. 안전한 대칭 암호화 성공: 핸드셰이크가 완료되고, 세션 키를 이용해 통신이 계속 진행됩니다.

</br>



### SSL/TLS 완전협상 과정 내용<참고만!>

</br>
1. Client Hello
* 클라이언트가 지원 가능한 SSL/TLS 버전, 암호 도구 목록(Cipher Suites), 압축 방식 등을 Server에 전달하는 메세지


* Client Random : 클라이언트가 생성하는 32Byte 난수값
- 임의 난수 28byte + 현재 시간 및 날짜 4byte으로, Master Secret 및 Key Block 생성 시, Salt 역할 수행


* Session ID : 서버 세션 식별을 위한 ID
- 클라이언트가 처음 세션을 생성할 때(완전 협상)에는, 빈값을 전달하고, 이미 생성된 세션을 재사용할 때(단축 협상)에는, 세션 ID를 담아서 전달


* 암호 도구 목록(Cipher Suites) : 클라이언트에서 지원 가능한 정보를 담아서 전송
- 키 교환 및 인증 알고리즘, 암호 명세(Cipher Spec)으로 구성 -> 형식 : SSL/TLS_(키 교환 및 인증 알고리즘)_WITH_(Cipher Spec)
- Cipher Spec(암호 명세) : 대칭 암호 알고리즘, 암호키 길이, 블럭 암호모드, HMAC용 해시 알고리즘 등으로 구성 </br> 
ex) TLS_RSA_WITH_AES_256_CBC_SHA256 : 키 교환 및 인증 알고리즘으로 RSA 사용, 대칭 암호 알고리즘으로 AES 사용, 암호키 길이 256bit, 블록 암호 모드는 CBC, HMAC용 해시 알고리즘은 SHA-256 사용 </br>
ex) TLS_DHE_DSS_WITH_AES_256_GCM_SHA256 : 키 교환 알고리즘으로 DHE(Ephemeral Diffie-Hellman), 인증 알고리즘으로 DSS, 대칭 암호 알고리즘 AES, 암호 키 길이 256, 블럭 암호 모드 GCM, HMAC용 해시 알고리즘 SHA-256 사용


* SSL/TLS에서 Diffie-Hellman 키 교환 유형
    1. Ephemeral Diffie-Hellman(임시 디피 헬먼) : 매 협상 시 마다, 새 Diffie Hellman 개인키(임의 정수값)을 생성, 공개 Diffie-Hellman 매개변수에 대한 서명(Cipher Suite의 인증/서명 알고리즘 이용)을 통해 인증을 수행

    2. Anonymous Diffie-Hellman(익명 디피 헬먼) : 임시 방식과 동일하게 새로운 Diffie-Hellman 개인키(임의 정수값)을 생성하나, 매개변수에 대한 인증을 수행하지 않아 MITM 공격에 취약, 해당 키 교환 방식의 Cipher Suite는 사용하지 않는 것을 권고


</br>
2. Server Hello

* 사용할 SSL/TLS 버전, 암호 도구(Ciper Suite), 압축 방식 등을 클라이언트에 전달하는 메세지

* Server Random : 서버가 생성하는 32byte 난수값
- 임의 난수 28byte + 현재 시간 및 날짜 4byte로, master secret 및 Key block 생성 시, Salt 역할 수행

* Session ID : 새롭게 생성하거나 존재하는 세션 ID 정보

</br>
3. Server Certificate(선택적 메세지)
* 필요 시, 서버 인증서 목록(서버 인증서 및 인증서에 서명한 인증기관들의 인증서 목록)을 클라이언트에게 전달


</br>
4. Server Key Exchange(선택적 메세지)
* 필요 시, 키 교환에 필요한 정보를 전달
- 키 교환 알고리즘으로 Ephemeral Diffie-Hellman을 사용할 시, 공개 Diffie-Hellman 매개변수(소수 p, 원시근 g, 서버 Diffie-Hellman 공개키)를 서명 알고리즘으로 서명하여, 서명값과 함께 전달

</br>
5. Certificate Request
(선택적 메세지)	* 필요 시, 클라이언트 인증을 위한 인증서를 요청
- 요청 시, 서버측에서 인증 가능한 인증기관 목록을 제공

</br>
6. Server Hello Done	* Server Hello 종료 과정을 알림

</br>
7. Client Certificate
(선택적 메세지)	* 필요 시(서버의 Certificate Request 메세지 수신 시), 클라이언트 인증서 목록을 전달

</br>
8. Client Key Exchange	* 키 교환에 필요한 premaster secret을 생성 후 서버에 전달하는 메세지
- 키 교환 알고리즘에 따라 premaster secret 생성 방식이 다름
- RSA : premaster secret(난수값) 생성 후 수신한 서버 인증서의 공개키를 이용하여 암호화 전송
- Diffie-Hellman : 클라이언트 Diffie-Hellman 공개키를 생성하여 서버에 전달, 클라이언트와 서버는 각각 Diffie-Hellman 연산을 통해 공통의 premaster secret 생성

</br>
9. Certificate Verify
(선택적 메세지)	* 필요 시(서버의 Certificate Request 메세지 수신 시), 클라이언트가 보낸 인증서에 대한 개인키를, 클라이언트가 가지고 있음을 증명
- 현재까지의 핸드셰이크 과정에서 주고 받은 메세지와, master secret을 조합한 해시값에, 클라이언트의 개인키로 서명하여 전달

</br>
10. Change Cipher Spec	* 협상한 암호명세(Cipher Spec)를 이후부터 적용/변경함을 알리는 메세지

</br>
11. Finished	* 협상 완료를 서버에 알림

</br>
12. Change Cipher Spec	* 협상한 암호명세(Cipher Spec)를 이후부터 적용/변경함을 알리는 메세지

</br>
13. Finished	* 협상 완료를 클라이언트에 알림
</br>


### 단축 협상 과정(Abbreviated Handshake)
[![2.png](https://i.postimg.cc/bNBctRCc/2.png)](https://postimg.cc/crwbqfGX)
