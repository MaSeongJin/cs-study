# 클래스 리스 ( Classless )
- 인터넷이 상용화 되며 폭발적으로 증가한 사용량에 따른 IP 주소 부족을 해결하기 위한 방법.
- Classful에서는 한개의 클래스 네트워크가 한 조직에 할당 되면 안쓰는 주소라도 다른 주소를 사용하기 어려워 클래스라는 개념을 버렸다.
	- 예를 들어, C클래스의 192.168.10.0 의 네트워크를 쓴다고 하면, 192.168.10.1부터 192.168.10.254 를 모두 다 쓰는 것!
- 클래스리스 네트워크에서는 별도로 네트워크와 호스트 주소를 나누는 구분자를 사용하는데 이것을 서브넷 마스크라고 한다.
	[![1.png](https://i.postimg.cc/bNFBFkxy/1.png)](https://postimg.cc/2VhG1q9M)
- 대표적인 프로토콜 RIPv2 , EIGRP, OSPF, BGP 프로토콜이 여기에 해당한다.
- 오른쪽 그림은 클래스리스 네트워크로, 클래스를 쪼개서 사용하는 방식입니다. 그리고 쪼개는 방식은 서브넷팅으로 진행합니다. 즉, 서브넷을 나누는 것입니다.
- 클래스를 쪼개서 사용한다는 건, C클래스(예시)의 네트워크를 여러 개로 나눈다는 뜻입니다.

# 서브넷 마스크 (Subnet Mask)
- **서브넷 마스크**는 ip주소에서 네트워크 ID와 호스트 ID로 구분하기 위한 목적으로 만들어졌다.
- 물론 ip클래스마다 주소 범위가 정해져있어서 앞자리만 보고도 어느 클래스인지 판별할 수는 있긴 하지만 보다 쉽게 구분하기 위해서 고유의 표기법으로 구분한다고 이해하면 된다.


## 서브넷 마스크 표현
- 서브넷 마스크는 IP주소와 똑같은 32비트 2진수로 표현된다.
- 255.255.255.0
- 여기서 아이피와 표현이 다른 점은 서브넷 마스크는 연속된 1과 연속된 0으로 구성되어있다는 것이다.
- 즉, 10011111.11011111.11110011.00000000 와 같이 1 중간에 0 이 들어오는 값은 가질 수 없고,
- 11111111.11111111.11111100.00000000처럼 1이 연속되거나 아닌 형태만 가질 수 있다는 말이다.
- 앞서, 서브넷 마스크는 네트워크 아이디와 호스트 아이디를 보다 편하게 구분하기 위해 사용된다라고 했죠.
- 아래 사진을 보면 그 원리를 쉽게 이해할 수 있을 것입니다.
- 서브넷 마스크 옥텟(1바이트)가 255면 즉 네트워크 아이디를 가리키게 되는 것입니다.
- 그래서 아주 간단하게 IP주소와 서브넷 마스크를 이용해서 이 IP가 어느 클래스인지 알 수 있습니다.

[![1.png](https://i.postimg.cc/9fDnRCkW/1.png)](https://postimg.cc/gwPD1Fd5)

## Prefix 표현
- 서브넷 마스크를 위보다 더욱 간소화해서 표현할 수도 있다.
- 바로 비트를 이용한 방법인데, IP 주소가 192.168.0.1/24 라면 뒤에 /24가 서브넷 마스크를 표현한 것이다.
- /24 라는 뜻은 32비트 중 앞에서부터 차례대로 1의 개수가 24개라는 의미이다. 나머지 32-24=8은 0으로 채워주면 서브넷 마스크 숫자가 되는 것이다.
	- /24  →  11111111.11111111.11111111.00000000
- 기존의 서브넷을 나타내는 방법 255.255.255.0 을 /24 즉, 네트워크에 해당하는 비트의 수로 표시하는 방식을 말한다고 보면 된다.
- 이렇게 하면 IP 주소를 입력할 때 192.168.1.17 255.255.255.0 를 192.168.1.17/24로 간략히 줄일 수 있게 된다.
- 서브넷 정보를 알려주기 위해 기존에는 4B가 필요했지만 6bit만 있으면 해당 정보를 전달할 수 있어서 네트워크 리소스를 절약할 수 있다.

1) 10.10.10.10/8 → A클래스
2) 172.16.1.10/16 → B클래스
3) 192.168.100.10/24 → C클래스

[![1.png](https://i.postimg.cc/PJJphVxF/1.png)](https://postimg.cc/4HCNQ5pz)

# 서브네팅 (Subnetting)
- 서브네팅이란 간단하게 말하자면 IP주소를 효울적으로 나누어 사용하기 위한 방법을 일컫는다.
- 네트워크 성능 보장, 자원을 효율적으로 분배하기 위해 네트워크 영역과 호스트 영역을 쪼개는 작업을 행한다.
- 서브넷팅을 하면 IP 할당 범위를 더 작은 단위로 나눌 수 있게 된다. (자신의 네트워크 주소를 더 작은 서브 네트워크로 2의 배수로 나누는 과정)
- 아래 사진과 같이, 만일 호스트를 50개만 사용하는 기업이 192.168.10.0/24 아이피 주소를 사용한다면 가정하면, C클래스이니까 총 256개의 주소를 할당하게 되는데, 256개 전체를 주기에는 낭비가 되니까, 이 256개를 절반으로 나누고(128개) 또 절반으로 나눈(64개) 주소를 기업에게 할당하고 남는 네트워크 주소는 다른 사용처로 할당하는 효율적인 작업이 바로 서브네팅 원리이다.

[![1.png](https://i.postimg.cc/zXnbNhXN/1.png)](https://postimg.cc/tY4CtYxv)

## 서브네팅 계산법
[![1.png](https://i.postimg.cc/kGg1CCW3/1.png)](https://postimg.cc/1nbc0LWJ)

## 주소범위를 절반으로 나누기 (2등분)
- 예를들어, 100개의 아이피를 사용하는 회사가 있다고 가정하자.
- 이 회사에게 아이피 대역을 할당할 예정이다.
- 100개 밖에 사용안하니 가장 작은 C클래스 대역을 줄 예정인데(192.168.10.0/24) 그래도 256개를 전부 주기에는 낭비가 있어 보인다.
- /24 라는 뜻은 1이 24개라는 뜻이다.
- 그러면 24비트까지가 네트워크 ID(3옥텟), 25번째 부터는 호스트 ID(1옥텟)이 된다.
1) 1100000.10101000.00001010.0000000
- 호스트ID가 8비트이니까 즉, 할당가능한 호스트 갯수는 2^8=256개가 된다.
- 하지만 회사는 100개의 호스트만 사용한다고 하니 256개를 전부 주는 것은 낭비이다. 256개의 주소를 절반으로 나누는 작업을 시행해보자.

[![2.png](https://i.postimg.cc/gkrSBYY3/2.png)](https://postimg.cc/KRSD1h3Y)
- 128개씩 두개로 나누기 위해 서브넷 구분 비트 라는 것을 지정해주어야 한다.
- 서브넷 구분 비트는, 이름 그대로 네트워크 주소를 어느 기준으로 쪼개서 서브넷(분할된 네트워크)을 만들어 구분할지 정하는 비트라 이해하면 된다.
- 서브넷 구분 비트는 항상 호스트 ID에서 왼쪽부터 결정이 되어야 한다는 특징이 있다.
- 즉, 호스트ID의 맨 왼쪽을 서브넷 구분 비트로 지정하게 되면, 0과 1로 구분되어지는데,
- 범위가 2진수로 다음과 같이 나뉘게 된다

**.00000000 ~ .01111111 (0 ~ 127)**

**.10000000 ~ .11111111 (128 ~ 255)**

즉, 호스트ID 맨왼쪽 비트가 0이냐 1이냐에 따라 서브넷이 두개로 분리되게 된다.
따라서 서브넷 구분 비트 2^7승 128값 기준으로 서브넷 주소 범위가 두개로 나뉘어진다.

[![3.png](https://i.postimg.cc/CMcrNZVF/3.png)](https://postimg.cc/G9sj3m2N)

나뉘어진 서브넷을 10진수로 아이피 전체 주소 범위를 표현하여 둘로 나뉘면 아래와 같이 된다.

[![4.png](https://i.postimg.cc/qqDmMFGt/4.png)](https://postimg.cc/9wTPLJKV)

이렇게 절반으로 나눈 한 서브넷 부분을 이제 회사에게 할당하고 나머지도 필요한 곳에 분배하면 된다.

이때 위에서 유의했듯이 어느 한 네트워크 범위의 가장 첫번째 주소(0) 과 마지막 주소는 네트워크/
브로드캐스트 주소로서 제외하여야 한다고 하였다.

[![5.png](https://i.postimg.cc/sD8nktXq/5.png)](https://postimg.cc/qzsXnD2x)

따라서 사용가능한 호스트는 

**192.168.10.1 ~ 192.168.10.126**

**192.168.10.129 ~ 192.168.10.254**

로 되게 된다.

## 주소범위를 4등분 나누기
- 이번엔 50개 호스트만 사용하는 회사가 있다고 하자.
- 이 역시 반으로 쪼개어도 128개를 통째로 주기에는 주소 낭비가 심하다. 따라서 같은 원리로 절반으로 또 쪼개 64개로 만들고 할당해주면 된다.
- 앞에서 했듯이 192.168.10.0/24 는 C클래스로서 사용가능한 호스트 갯수는 256개이다.
- 이를 4등분해서 64개의 호스트를 가진 서브넷 4개로 나누는 것이다.
- 4등분 하기위해 서브넷 구분비트를 왼쪽에서 2비트로 지정한다.

[![1.png](https://i.postimg.cc/Pfb3rYn4/1.png)](https://postimg.cc/6T3LM732)

러면 서브넷 구분비트는 00, 01, 10, 11 로 총 4개로 구분되어질 수 있고, 이를 적용해보면

 

**00000000 ~ 00111111**

**01000000 ~ 01111111**

**10000000 ~ 10111111**

**11000000 ~ 11111111**

로 범위가 4등분되어 나뉘어 줄수 있다. 이 범위를 아이피 주소로 표현하자면 다음과 같이 된다.

[![2.png](https://i.postimg.cc/ydmPx4td/2.png)](https://postimg.cc/1nz67T9h)
- 여기서 네트워크 주소와 브로드 캐스트 주소의 특징을 볼수 있는데,
네트워크 주소는 항상 짝수로 나온다는 특징과 브로드 캐스트 주소는 항상 홀수로 나온다는 특징이 있다.
- 따라서 브로드 캐스트 주소를 구했는데 짝수가 나온다면 잘못 계산한것으로 보면 된다.

[![3.png](https://i.postimg.cc/j50cRd8m/3.png)](https://postimg.cc/2qGhwmN7)

- 어쨋든 간에 256개의 호스트 주소를 4개로 나뉘었고 이를 범위로 표현하면 다음과 같이 된다.
- 이중 서브넷 하나를 회사에게 할당해주면 끝난다.

[![4.png](https://i.postimg.cc/FH6Gnx09/4.png)](https://postimg.cc/21441hHJ)

## 주소범위를 복합적으로 나누기
이번에는 3층 건물이 있고 각 층마다 회사가 들어섰는데, 1층은 100개의 주소, 2층은 50개, 3층은 30개만 사용한다고 가정하자.
[![5.png](https://i.postimg.cc/TYRky1RX/5.png)](https://postimg.cc/WtHmC2F9)
- 주소를 원하는 크기만큼 나눌때는 반드시 크기가 큰 것 부터 나눠야 한다.
- 즉, 1층의 100개 부터 나누어 할당해줘야 한다는 말이다.
- 1층의 호스트 100대의 아이피주소를 할당하기위해서는 7개의 호스트 ID 비트가 필요하다.
- 왜냐하면 2^7으로서 128개가 되니까 100개를 충분히 할당 할 수 있기 때문이다.
- 그러면 25비트가 네트워크 ID 그리고 나머지 7비트가 호스트 ID가 됨으로서 다음 그림과 같이 표현된다.

[![6.png](https://i.postimg.cc/D07cbp3c/6.png)](https://postimg.cc/xJFmwRCk)
- 이제 이 호스트 ID를 처음과 끝을 구해준다.
- 호스트ID의 아이피 주소의 범위는 .00000000 ~ .01111111 (0 ~ 127) 이 되니까,
- 10진수로 표현하면 192.168.10.0 ~ 192.168.10.127 이되고 이 아이피 범위 서브넷을 1층에 할당해주면 된다.

[![7.png](https://i.postimg.cc/mZSjG47p/7.png)](https://postimg.cc/xqcMKWxL)

- 이번에는 2층의 50대의 호스트를 할당하기 위해선 6개의 비트만 호스트 ID만 있으면 된다.
- 왜냐하면 2^6 (64)개만 할당해주면 되기 때문이다.
- 단 유의할 점은 이 64개는 처음에 1층에 할당하고 남은 나머지 128개의 호스트 주소 범위를 쪼개서 나눠 할당해야 한다.
- 위에서 1층에 호스트를 할당하기 위해 256개를 절반으로 나누었는데

**192.168.10.0 ~ 192.168.10.127**

**192.168.10.128 ~ 192.168.10.256**
- 그중 192.168.10.0 ~ 192.168.10.127 는 이미 1층에 할당헀으니,
- 나머지 192.168.10.128 ~ 192.168.10.256 범위에서 쪼개어 나누면 된다는 말이다.

 - 호스트 ID 비트는 6개이므로 이를 2진수로 표현해서 처음과 끝을 구해보면 **.10000000 ~ 10111111 (128 ~ 191)** 가 되고 이 범위(64개)를 2층에 할당해주면 된다.

[![8.png](https://i.postimg.cc/cCTB77sG/8.png)](https://postimg.cc/ctg30ngF)

- 원래 아이피 주소 192.168.10.0 ~ 192.168.10.255 에서 192.168.10.0 ~ 192.168.10.127는 1층에 할당했고, 192.168.10.128 ~ 192.168.10.191 은 2층에 할당 했다.
- 이제 나머지 192.168.10.192 ~ 192.168.10.255 에서 3층을 같은 방식으로 반의 반으로 쪼개서(32개) 할당해 주면 된다.
- 3층은 30개만 사용하니 2^5(32)만 필요해 호스트 ID는 5비트가 되고, 이를 범위를 구하게 되면 **.11000000 ~ .11011111 (192 ~ 223)** 가 되서 즉, 192.168.10.192 ~ 192.168.10.223 범위의 서브넷을 할당해주면 끝난다.

[![9.png](https://i.postimg.cc/155HmdHm/9.png)](https://postimg.cc/G9VYzqVV)

# 문제
문제1. 200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 subnet으로 나누고 ip subnet-zero를 적용했다. 이때 서브네팅 된 네트워크 중 10번째 네트워크의 broadcast IP 주소는?

① 200.1.1.159

② 201.1.5.175

③ 202.1.11.254

④ 203.1.255.245

​<details>
<summary>문제 해설</summary>
<div markdown="1">
답 ① </br></br>

200.1.1.0/24 네트워크의 서브넷 마스크는 1의 개수가 24개, 즉 11111111 11111111 11111111 00000000 → 255.255.255.0인 C클래스에 속하는 네트워크이다. 이 네트워크를 10개의 Subnet으로 나눠야 하는데, Subnet을 나눌 때는 서브넷 마스크가 0인 부분, 즉 마지막 비트를 이용해 구분할 수 있다. Subnet을 나눌 때 왼쪽 기준으로 10개가 포함된 Bit만큼 네트워크로 할당하고 나머지 비트로 호스트를 구성하면 된다. 10개가 포함되는 비트는 2^4 = 16 ( 2^3 = 8 은 10개를 포함할 수 없으므로)이므로 4비트를 제외한 나머지 4비트로 호스트를 구성한다.
</br>

[![2.png](https://i.postimg.cc/4y1mxX1P/2.png)](https://postimg.cc/5Q6xPdTQ)

</br>

 호스트ID가 4Bit로 설정되었고, 문제에서 FLSM 방식을 이용한다고 했으므로 10개의 네트워크에 고정된 크기인 16개(2^4 = 16, 이 때 4는 호스트ID의 4Bit를 의미한다.)씩 할당하면 다음과 같다.

</br>

[![1.png](https://i.postimg.cc/J08s8sjt/1.png)](https://postimg.cc/9RxmtF8j)

</br>
문제에서 요구한 것은 10번째 네트워크의 broadcast주소이다. broadcast 주소란 해당 IP 주소 범위에서 가장 마지막 주소를 의미하므로, 200.1.1.159가 정답이다.

* ip subnet-zero
: Subnet 부분이 모두 0인 200.1.1.0 과 200.1.1.255를 사용(IP 부족 해결하기 위함)
</div>
</details>



​
